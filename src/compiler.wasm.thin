unsafe function memcpy(target: uint, source: uint, length: uint): void {
  // No-op if either of the inputs are null
  if (source == 0 || target == 0) {
    return;
  }

  // Optimized aligned copy
  if (length >= 16 && source % 4 == target % 4) {
    // Pick off the beginning
    while (target % 4 != 0) {
      (target as UBytePtr).value = (source as UBytePtr).value;
      target = target + 1;
      source = source + 1;
      length = length - 1;
    }

    // Pick off the end
    while (length % 4 != 0) {
      length = length - 1;
      ((target + length) as UBytePtr).value = ((source + length) as UBytePtr).value;
    }

    // Zip over the middle
    var end = target + length;
    while (target < end) {
      (target as UIntPtr).value = (source as UIntPtr).value;
      target = target + 4;
      source = source + 4;
    }
  }

  // Slow unaligned copy
  else {
    var end = target + length;
    while (target < end) {
      (target as UBytePtr).value = (source as UBytePtr).value;
      target = target + 1;
      source = source + 1;
    }
  }
}

extern function Compiler_resetHeapPointer(): void {
  unsafe {
    currentHeapPointer = originalHeapPointer; // Reset the heap
  }
}
