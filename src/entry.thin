class CompileResult {
  log: Log;
  global: Node;
  context: CheckContext;
  wasm: ByteArray;
  js: String;
}

extern function CompileResult_new(): CompileResult {
  var result = new CompileResult();
  result.log = new Log();
  result.global = new Node();
  result.global.kind = NodeKind.GLOBAL;

  var malloc = CompileResult_addInput(result, String_new("<malloc>"), String_new(`
    var __mallocOffset = 0;

    function __malloc(sizeOf: int): int {
      var offset = (__mallocOffset + 7) & ~7; // Align all allocations to 8 bytes
      __mallocOffset = offset + sizeOf; // Use a simple bump allocator for now
      return offset;
    }
  `));
  malloc.flags = malloc.flags | SOURCE_FLAG_WASM_ONLY;

  return result;
}

extern function CompileResult_addInput(result: CompileResult, name: String, contents: String): Source {
  var source = new Source();
  source.name = name;
  source.contents = contents;

  var token = tokenize(source, result.log);

  if (token != null) {
    var file = parse(token, result.log);

    if (file != null) {
      while (file.firstChild != null) {
        var child = file.firstChild;
        child.remove();
        result.global.appendChild(child);
      }
    }
  }

  return source;
}

extern function CompileResult_finish(result: CompileResult): void {
  result.context = check(result.global, result.log);

  if (result.log.first == null) {
    result.wasm = ByteArray_new();
    wasmEmit(result.global, result.context, result.wasm);

    result.js = jsEmit(result.global, result.context);
  }
}

extern function CompileResult_wasm(result: CompileResult): ByteArray {
  return result.wasm;
}

extern function CompileResult_js(result: CompileResult): String {
  return result.js;
}

extern function CompileResult_log(result: CompileResult): String {
  return result.log.toString();
}
