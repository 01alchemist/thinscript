class LineColumn {
  line: int; // 0-based
  column: int; // 0-based
}

class Source {
  name: string;
  contents: string;

  // These are for internal use by the compiler
  next: Source;
  isLibrary: bool;
  firstToken: Token;
  file: Node;

  indexToLineColumn(index: int): LineColumn {
    var contents = this.contents;
    var lastNewline = 0;
    var line = 0;
    var i = 0;

    // Just count the number of lines from the beginning of the file for now
    while (i < index) {
      if (string_get(contents, i) == '\n') {
        lastNewline = i + 1;
        line = line + 1;
      }
      i = i + 1;
    }

    var location = new LineColumn();
    location.line = line;
    location.column = index - lastNewline;
    return location;
  }
}

class Range {
  source: Source;
  start: int;
  end: int;

  toString(): string {
    return this.source.contents.slice(this.start, this.end);
  }

  equals(other: Range): bool {
    return
      this.source == other.source &&
      this.start == other.start &&
      this.end == other.end;
  }

  enclosingLine(): Range {
    var contents = this.source.contents;
    var start = this.start;
    var end = this.start;

    while (start > 0 && string_get(contents, start - 1) != '\n') {
      start = start - 1;
    }

    var length = contents.length;
    while (end < length && string_get(contents, end) != '\n') {
      end = end + 1;
    }

    return createRange(this.source, start, end);
  }

  rangeAtEnd(): Range {
    return createRange(this.source, this.end, this.end);
  }
}

function createRange(source: Source, start: int, end: int): Range {
  assert(start <= end);
  var range = new Range();
  range.source = source;
  range.start = start;
  range.end = end;
  return range;
}

function spanRanges(left: Range, right: Range): Range {
  assert(left.source == right.source);
  assert(left.start <= right.start);
  assert(left.end <= right.end);
  return createRange(left.source, left.start, right.end);
}

enum DiagnosticKind {
  ERROR,
  WARNING,
}

class Diagnostic {
  range: Range;
  message: string;
  kind: DiagnosticKind;
  next: Diagnostic;

  appendSourceName(builder: StringBuilder, location: LineColumn): void {
    builder
      .append(this.range.source.name)
      .appendChar(':')
      .append(string_intToString(location.line + 1))
      .appendChar(':')
      .append(string_intToString(location.column + 1))
      .append(": ");
  }

  appendKind(builder: StringBuilder): void {
    builder.append(this.kind == DiagnosticKind.ERROR ? "error: " : "warning: ");
  }

  appendMessage(builder: StringBuilder): void {
    builder.append(this.message).appendChar('\n');
  }

  appendLineContents(builder: StringBuilder, location: LineColumn): void {
    var range = this.range;
    var contents = range.source.contents;
    var length = contents.length;
    var start = range.start - location.column;
    var end = range.start;

    while (end < length && string_get(contents, end) != '\n') {
      end = end + 1;
    }

    builder.appendSlice(contents, start, end).appendChar('\n');
  }

  appendRange(builder: StringBuilder, location: LineColumn): void {
    var range = this.range;
    var column = location.column;
    var contents = range.source.contents;

    // Whitespace
    while (column > 0) {
      builder.appendChar(' ');
      column = column - 1;
    }

    // Single character
    if (range.end - range.start <= 1) {
      builder.appendChar('^');
    }

    // Multiple characters
    else {
      var i = range.start;
      while (i < range.end && string_get(contents, i) != '\n') {
        builder.appendChar('~');
        i = i + 1;
      }
    }

    builder.appendChar('\n');
  }
}

class Log {
  first: Diagnostic;
  last: Diagnostic;

  error(range: Range, message: string): void {
    this.append(range, message, DiagnosticKind.ERROR);
  }

  warning(range: Range, message: string): void {
    this.append(range, message, DiagnosticKind.WARNING);
  }

  append(range: Range, message: string, kind: DiagnosticKind): void {
    var diagnostic = new Diagnostic();
    diagnostic.range = range;
    diagnostic.message = message;
    diagnostic.kind = kind;

    if (this.first == null) this.first = diagnostic;
    else this.last.next = diagnostic;
    this.last = diagnostic;
  }

  toString(): string {
    var builder = StringBuilder_new();
    var diagnostic = this.first;

    while (diagnostic != null) {
      var location = diagnostic.range.source.indexToLineColumn(diagnostic.range.start);
      diagnostic.appendSourceName(builder, location);
      diagnostic.appendKind(builder);
      diagnostic.appendMessage(builder);
      diagnostic.appendLineContents(builder, location);
      diagnostic.appendRange(builder, location);
      diagnostic = diagnostic.next;
    }

    return builder.finish();
  }

  hasErrors(): bool {
    var diagnostic = this.first;

    while (diagnostic != null) {
      if (diagnostic.kind == DiagnosticKind.ERROR) {
        return true;
      }
      diagnostic = diagnostic.next;
    }

    return false;
  }
}
