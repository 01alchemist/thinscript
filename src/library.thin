function libraryJS(): string {
  return `
unsafe function ByteArray_new(): int;
unsafe function ByteArray_length(self: int): int;
unsafe function ByteArray_getByte(self: int, index: int): ubyte;
unsafe function ByteArray_setByte(self: int, index: int, byte: ubyte): void;
unsafe function ByteArray_appendByte(self: int, byte: ubyte): void;

class ByteArray {
  unsafe _handle: int;

  length(): int {
    unsafe {
      if (this._handle != 0) {
        return ByteArray_length(this._handle);
      }
    }
    return 0;
  }

  get(index: int): ubyte {
    unsafe {
      if (this._handle != 0) {
        return ByteArray_getByte(this._handle, index);
      }
    }
    return 0;
  }

  set(index: int, value: ubyte): void {
    unsafe {
      if (this._handle != 0) {
        ByteArray_setByte(this._handle, index, value);
      }
    }
  }

  append(value: ubyte): void {
    unsafe {
      if (this._handle == 0) {
        this._handle = ByteArray_new();
      }
      ByteArray_appendByte(this._handle, value);
    }
  }

  handle(): int {
    unsafe {
      return this._handle;
    }
  }
}
`;
}

function libraryWASM(): string {
  return `
class ByteArray {
  unsafe _data: uint;
  unsafe _length: uint;
  unsafe _capacity: uint;

  length(): int {
    unsafe {
      return this._length as int;
    }
  }

  get(index: int): ubyte {
    unsafe {
      if ((index as uint) >= this._length) {
        return ((this._data as int + index) as UBytePtr).value;
      }
      return 0;
    }
  }

  set(index: int, value: ubyte): void {
    unsafe {
      if ((index as uint) < this._length) {
        ((this._data as int + index) as UBytePtr).value = value;
      }
    }
  }

  append(value: ubyte): void {
    unsafe {
      var offset = this._length;
      this._resize(offset + 1);
      ((this._data + offset) as UBytePtr).value = value;
    }
  }

  handle(): int {
    unsafe {
      return this as int;
    }
  }

  _resize(length: uint): void {
    unsafe {
      if (length > this._capacity) {
        var capacity = length * 2;
        var data = malloc(capacity);
        memcpy(data, this._data, this._length);
        this._capacity = capacity;
        this._data = data;
      }
      this._length = length;
    }
  }
}

unsafe class UBytePtr {
  value: ubyte;
}

unsafe class IntPtr {
  value: int;
}

// This will be filled in by the code generator with the inital heap pointer
unsafe var mallocOffset: uint = 0;

unsafe function malloc(sizeOf: uint): uint {
  // Align all allocations to 8 bytes
  var offset = (mallocOffset + 7) & ~7 as uint;

  // Use a simple bump allocator for now
  mallocOffset = offset + sizeOf;

  return offset;
}

unsafe function memcpy(to: uint, from: uint, length: uint): void {
  // Early out: nothing to do
  if (from == to || length == 0) {
    return;
  }

  // Forwards
  if (from > to) {
    while (length != 0) {
      (to as UBytePtr).value = (from as UBytePtr).value;
      to = to + 1;
      from = from + 1;
      length = length - 1;
    }
  }

  // Backwards
  else {
    to = to + length;
    from = from + length;
    while (length != 0) {
      to = to - 1;
      from = from - 1;
      (to as UBytePtr).value = (from as UBytePtr).value;
      length = length - 1;
    }
  }
}
`;
}
