function library(): string {
  return `
#if WASM

  // These will be filled in by the WebAssembly code generator
  unsafe var currentHeapPointer: uint = 0;
  unsafe var originalHeapPointer: uint = 0;

  extern unsafe function malloc(sizeOf: uint): uint {
    // Align all allocations to 8 bytes
    var offset = (currentHeapPointer + 7) & ~7 as uint;
    sizeOf = (sizeOf + 7) & ~7 as uint;

    // Use a simple bump allocator for now
    var limit = offset + sizeOf;
    currentHeapPointer = limit;

    // Make sure the memory starts off at zero
    var ptr = offset;
    while (ptr < limit) {
      *(ptr as *int) = 0;
      ptr = ptr + 4;
    }

    return offset;
  }

  unsafe function memcpy(target: uint, source: uint, length: uint): void {
    // No-op if either of the inputs are null
    if (source == 0 || target == 0) {
      return;
    }

    // Optimized aligned copy
    if (length >= 16 && source % 4 == target % 4) {
      // Pick off the beginning
      while (target % 4 != 0) {
        *(target as *byte) = *(source as *byte);
        target = target + 1;
        source = source + 1;
        length = length - 1;
      }

      // Pick off the end
      while (length % 4 != 0) {
        length = length - 1;
        *((target + length) as *byte) = *((source + length) as *byte);
      }

      // Zip over the middle
      var end = target + length;
      while (target < end) {
        *(target as *int) = *(source as *int);
        target = target + 4;
        source = source + 4;
      }
    }

    // Slow unaligned copy
    else {
      var end = target + length;
      while (target < end) {
        *(target as *byte) = *(source as *byte);
        target = target + 1;
        source = source + 1;
      }
    }
  }

  declare class bool {
    toString(): string {
      return this ? "true" : "false";
    }
  }

  declare class sbyte {
    toString(): string {
      return (this as int).toString();
    }
  }

  declare class byte {
    toString(): string {
      return (this as uint).toString();
    }
  }

  declare class short {
    toString(): string {
      return (this as int).toString();
    }
  }

  declare class ushort {
    toString(): string {
      return (this as uint).toString();
    }
  }

  declare class int {
    toString(): string {
      // Special-case this to keep the rest of the code simple
      if (this == -2147483648) {
        return "-2147483648";
      }

      // Treat this like an unsigned integer prefixed by '-' if it's negative
      return internalIntToString((this < 0 ? -this : this) as uint, this < 0);
    }
  }

  declare class uint {
    toString(): string {
      return internalIntToString(this, false);
    }
  }

  function internalIntToString(value: uint, sign: bool): string {
    // Avoid allocation for common cases
    if (value == 0) return "0";
    if (value == 1) return sign ? "-1" : "1";

    unsafe {
      // Determine how many digits we need
      var length = ((sign ? 1 : 0) + (
        value >= 100000000 ?
          value >= 1000000000 ? 10 : 9 :
        value >= 10000 ?
          value >= 1000000 ?
            value >= 10000000 ? 8 : 7 :
            value >= 100000 ? 6 : 5 :
          value >= 100 ?
            value >= 1000 ? 4 : 3 :
            value >= 10 ? 2 : 1)) as uint;

      var ptr = string_new(length) as uint;
      var end = ptr + 4 + length * 2;

      if (sign) {
        *((ptr + 4) as *ushort) = '-';
      }

      while (value != 0) {
        end = end - 2;
        *(end as *ushort) = (value % 10 + '0') as ushort;
        value = value / 10;
      }

      return ptr as string;
    }
  }

  function string_new(length: uint): string {
    unsafe {
      var ptr = malloc(4 + length * 2);
      *(ptr as *uint) = length;
      return ptr as string;
    }
  }

  declare class string {
    charAt(index: int): string {
      return this.slice(index, index + 1);
    }

    charCodeAt(index: int): ushort {
      return this[index];
    }

    get length(): int {
      unsafe {
        return *(this as *int);
      }
    }

    operator [] (index: int): ushort {
      if (index as uint < this.length as uint) {
        unsafe {
          return *((this as int + index * 2 + 4) as *ushort);
        }
      }
      return 0;
    }

    operator == (other: string): bool {
      unsafe {
        if (this as uint == other as uint) return true;
        if (this as uint == 0 || other as uint == 0) return false;

        var length = this.length;

        // Check the length first
        if (length != other.length) {
          return false;
        }

        // Check the content next
        var ai = this as uint + 4;
        var bi = other as uint + 4;
        var an = ai + ((length * 2) & ~3) as uint;

        // Compare 32-bit values for speed (4-byte alignment is manditory)
        while (ai < an) {
          if (*(ai as *int) != *(bi as *int)) {
            return false;
          }
          ai = ai + 4;
          bi = bi + 4;
        }

        // Compare trailing 16-bit values
        if (length as uint % 2 != 0 && *(ai as *ushort) != *(bi as *ushort)) {
          return false;
        }
      }

      return true;
    }

    slice(start: int, end: int): string {
      var limit = this.length;

      if (start < 0) start = 0;
      else if (start > limit) start = limit;

      if (end < start) end = start;
      else if (end > limit) end = limit;

      unsafe {
        var length = (end - start) as uint;
        var ptr = string_new(length);
        memcpy(ptr as uint + 4, this as uint + 4 + start as uint * 2, length * 2);
        return ptr;
      }
    }
  }

#else

  declare class bool {
    toString(): string;
  }

  declare class sbyte {
    toString(): string;
  }

  declare class byte {
    toString(): string;
  }

  declare class short {
    toString(): string;
  }

  declare class ushort {
    toString(): string;
  }

  declare class int {
    toString(): string;
  }

  declare class uint {
    toString(): string;
  }

  declare class string {
    charAt(index: int): string;
    charCodeAt(index: int): int;
    get length(): int;
    operator [] (index: int): int { return this.charCodeAt(index); }
    operator == (other: string): bool;
    slice(start: int, end: int): string;
  }

#endif
`;
}
