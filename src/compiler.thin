extern enum CompileTarget {
  NONE,
  C,
  JAVASCRIPT,
  WEBASSEMBLY,
}

class Compiler {
  log: Log;
  global: Node;
  firstSource: Source;
  lastSource: Source;
  preprocessor: Preprocessor;
  target: CompileTarget;
  context: CheckContext;
  wasm: ByteArray;
  js: string;
  c: string;

  initialize(target: CompileTarget): void {
    assert(this.log == null);
    this.log = new Log();
    this.global = new Node();
    this.global.kind = NodeKind.GLOBAL;
    this.preprocessor = new Preprocessor();
    this.target = target;
    this.addInput("<native>", library());

    if (target == CompileTarget.C) {
      this.preprocessor.define("C", true);
    }

    else if (target == CompileTarget.JAVASCRIPT) {
      this.preprocessor.define("JS", true);
    }

    else if (target == CompileTarget.WEBASSEMBLY) {
      this.preprocessor.define("WASM", true);
    }
  }

  addInput(name: string, contents: string): void {
    var source = new Source();
    source.name = name;
    source.contents = contents;

    if (this.firstSource == null) this.firstSource = source;
    else this.lastSource.next = source;
    this.lastSource = source;
  }

  finish(): bool {
    Profiler_begin();

    var source = this.firstSource;
    while (source != null) {
      source.firstToken = tokenize(source, this.log);
      source = source.next;
    }

    Profiler_end("lexing");
    Profiler_begin();

    source = this.firstSource;
    while (source != null) {
      this.preprocessor.run(source, this.log);
      source = source.next;
    }

    Profiler_end("preprocessing");
    Profiler_begin();

    source = this.firstSource;
    while (source != null) {
      if (source.firstToken != null) {
        var file = parse(source.firstToken, this.log);

        if (file != null) {
          while (file.firstChild != null) {
            var child = file.firstChild;
            child.remove();
            this.global.appendChild(child);
          }
        }
      }
      source = source.next;
    }

    Profiler_end("parsing");
    Profiler_begin();

    assert(this.context == null);
    this.context = check(this.global, this.log);

    Profiler_end("checking");

    if (this.log.first != null) {
      return false;
    }

    Profiler_begin();

    if (this.target == CompileTarget.C) {
      this.c = cEmit(this.global, this.context);
    }

    else if (this.target == CompileTarget.JAVASCRIPT) {
      this.js = jsEmit(this.global, this.context);
    }

    else if (this.target == CompileTarget.WEBASSEMBLY) {
      this.wasm = new ByteArray();
      wasmEmit(this.global, this.context, this.wasm);
    }

    Profiler_end("emitting");

    return true;
  }
}

extern function Compiler_new(target: CompileTarget): Compiler {
  var compiler = new Compiler();
  compiler.initialize(target);
  return compiler;
}

extern function Compiler_callAddInput(compiler: Compiler, name: string, contents: string): void {
  compiler.addInput(name, contents);
}

extern function Compiler_define(compiler: Compiler, text: string): void {
  compiler.preprocessor.define(text, true);
}

extern function Compiler_callFinish(compiler: Compiler): bool {
  compiler.finish();
  return !compiler.log.hasErrors();
}

extern function Compiler_wasm(compiler: Compiler): ByteArray {
  return compiler.wasm;
}

extern function Compiler_js(compiler: Compiler): string {
  return compiler.js;
}

extern function Compiler_c(compiler: Compiler): string {
  return compiler.c;
}

extern function Compiler_log(compiler: Compiler): string {
  return compiler.log.toString();
}

#if WASM
  unsafe function memcpy(target: uint, source: uint, length: uint): void {
    // No-op if either of the inputs are null
    if (source == 0 || target == 0) {
      return;
    }

    // Optimized aligned copy
    if (length >= 16 && source % 4 == target % 4) {
      // Pick off the beginning
      while (target % 4 != 0) {
        (target as UBytePtr).value = (source as UBytePtr).value;
        target = target + 1;
        source = source + 1;
        length = length - 1;
      }

      // Pick off the end
      while (length % 4 != 0) {
        length = length - 1;
        ((target + length) as UBytePtr).value = ((source + length) as UBytePtr).value;
      }

      // Zip over the middle
      var end = target + length;
      while (target < end) {
        (target as UIntPtr).value = (source as UIntPtr).value;
        target = target + 4;
        source = source + 4;
      }
    }

    // Slow unaligned copy
    else {
      var end = target + length;
      while (target < end) {
        (target as UBytePtr).value = (source as UBytePtr).value;
        target = target + 1;
        source = source + 1;
      }
    }
  }

  extern unsafe function Compiler_resetHeapPointer(): void {
    currentHeapPointer = originalHeapPointer; // Reset the heap
    stringBuilderPool = null;
  }
#endif
