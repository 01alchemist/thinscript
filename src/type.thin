const POINTER_SIZE = 4;

enum ConversionKind {
  IMPLICIT,
  EXPLICIT,
}

class Type {
  symbol: Symbol;

  isClass(): bool {
    return this.symbol.kind == SymbolKind.TYPE_CLASS;
  }

  isEnum(): bool {
    return this.symbol.kind == SymbolKind.TYPE_ENUM;
  }

  isInteger(): bool {
    return (this.symbol.flags & SYMBOL_FLAG_NATIVE_INTEGER) != 0 || this.isEnum();
  }

  isUnsigned(): bool {
    return (this.symbol.flags & SYMBOL_FLAG_IS_UNSIGNED) != 0;
  }

  isReference(): bool {
    return (this.symbol.flags & SYMBOL_FLAG_IS_REFERENCE) != 0;
  }

  underlyingType(context: CheckContext): Type {
    return this.isEnum() ? context.intType : this;
  }

  integerBitCount(): int {
    return this.symbol.byteSize * 8;
  }

  integerBitMask(): uint {
    return ~0 as uint >> (32 - this.integerBitCount()) as uint;
  }

  allocationSizeOf(): int {
    return this.symbol.byteSize;
  }

  allocationAlignmentOf(): int {
    return this.allocationSizeOf(); // This is true right now
  }

  variableSizeOf(): int {
    return this.isClass() ? POINTER_SIZE : this.symbol.byteSize;
  }

  variableAlignmentOf(): int {
    return this.variableSizeOf(); // This is true right now
  }

  toString(): string {
    return this.symbol.name;
  }

  findMember(name: string, hint: ScopeHint): Symbol {
    var symbol = this.symbol;
    return symbol != null && symbol.scope != null ? symbol.scope.findLocal(name, hint) : null;
  }

  hasInstanceMembers(): bool {
    var symbol = this.symbol;
    return symbol != null && (symbol.kind == SymbolKind.TYPE_CLASS || symbol.kind == SymbolKind.TYPE_NATIVE);
  }
}
