class CheckContext {
  log: Log;
  currentReturnType: Type;

  // Native types
  boolType: Type;
  byteType: Type;
  errorType: Type;
  intType: Type;
  nullType: Type;
  shortType: Type;
  stringType: Type;
  ubyteType: Type;
  uintType: Type;
  ushortType: Type;
  voidType: Type;
}

function addScopeToSymbol(symbol: Symbol, parentScope: Scope): void {
  var scope = new Scope();
  scope.parent = parentScope;
  scope.symbol = symbol;
  symbol.scope = scope;
}

function linkSymbolToNode(symbol: Symbol, node: Node): void {
  node.symbol = symbol;
  node.scope = symbol.scope;
  symbol.range = node.internalRange != null ? node.internalRange : node.range;
  symbol.node = node;
}

function initialize(context: CheckContext, node: Node, parentScope: Scope): void {
  if (node.parent != null) {
    var kind = node.kind;
    var parentKind = node.parent.kind;

    // Validate node placement
    if (kind != NodeKind.VARIABLE && (kind != NodeKind.FUNCTION || parentKind != NodeKind.CLASS) && (parentKind == NodeKind.GLOBAL) !=
        (kind == NodeKind.CLASS || kind == NodeKind.ENUM || kind == NodeKind.FUNCTION || kind == NodeKind.CONSTANTS)) {
      context.log.error(node.range, String_new("This statement is not allowed here"));
    }
  }

  // Global
  if (node.kind == NodeKind.GLOBAL) {
    assert(parentScope == null);

    var symbol = new Symbol();
    symbol.kind = SymbolKind.TYPE_GLOBAL;
    symbol.name = String_new("<global>");
    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;
    symbol.state = SymbolState.INITIALIZED;
    addScopeToSymbol(symbol, parentScope);
    linkSymbolToNode(symbol, node);
    parentScope = symbol.scope;

    // Initialize native types
    context.boolType = parentScope.defineNativeType(context.log, "bool", 1);
    context.errorType = parentScope.defineNativeType(context.log, "<error>", 0);
    context.nullType = parentScope.defineNativeType(context.log, "null", 0);
    context.stringType = parentScope.defineNativeType(context.log, "string", POINTER_SIZE);
    context.voidType = parentScope.defineNativeType(context.log, "void", 0);

    // Native integer types
    context.byteType = parentScope.defineNativeIntegerType(context.log, "byte", 1, false);
    context.intType = parentScope.defineNativeIntegerType(context.log, "int", 4, false);
    context.shortType = parentScope.defineNativeIntegerType(context.log, "short", 2, false);
    context.ubyteType = parentScope.defineNativeIntegerType(context.log, "ubyte", 1, true);
    context.uintType = parentScope.defineNativeIntegerType(context.log, "uint", 4, true);
    context.ushortType = parentScope.defineNativeIntegerType(context.log, "ushort", 2, true);
  }

  // Class
  else if (node.kind == NodeKind.CLASS || node.kind == NodeKind.ENUM) {
    var symbol = new Symbol();
    symbol.kind = node.kind == NodeKind.CLASS ? SymbolKind.TYPE_CLASS : SymbolKind.TYPE_ENUM;
    symbol.name = node.stringValue;
    addScopeToSymbol(symbol, parentScope);
    linkSymbolToNode(symbol, node);
    parentScope.define(context.log, symbol);
    parentScope = symbol.scope;
  }

  // Function
  else if (node.kind == NodeKind.FUNCTION) {
    var symbol = new Symbol();
    symbol.kind =
      node.parent.kind == NodeKind.CLASS ? SymbolKind.FUNCTION_INSTANCE :
      SymbolKind.FUNCTION_GLOBAL;
    symbol.name = node.stringValue;
    addScopeToSymbol(symbol, parentScope);
    linkSymbolToNode(symbol, node);
    parentScope.define(context.log, symbol);
    parentScope = symbol.scope;

    // All instance functions have a special "this" type
    if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
      var parent = node.parent.symbol;
      assert(parent.kind == SymbolKind.TYPE_CLASS);
      initializeSymbol(context, parent);
      node.insertChildBefore(node.firstChild, createVariable(String_new("this"), createType(parent.resolvedType), null));
    }
  }

  // Variable
  else if (node.kind == NodeKind.VARIABLE) {
    var symbol = new Symbol();
    symbol.kind =
      node.parent.kind == NodeKind.CLASS ? SymbolKind.VARIABLE_INSTANCE :
      node.parent.kind == NodeKind.FUNCTION ? SymbolKind.VARIABLE_ARGUMENT :
      node.parent.kind == NodeKind.CONSTANTS || node.parent.kind == NodeKind.ENUM ? SymbolKind.VARIABLE_CONSTANT :
      SymbolKind.VARIABLE_LOCAL;
    symbol.name = node.stringValue;
    symbol.scope = parentScope;
    linkSymbolToNode(symbol, node);
    parentScope.define(context.log, symbol);
  }

  // Block
  else if (node.kind == NodeKind.BLOCK) {
    if (node.parent.kind != NodeKind.FUNCTION) {
      var scope = new Scope();
      scope.parent = parentScope;
      parentScope = scope;
    }
    node.scope = parentScope;
  }

  // Children
  var child = node.firstChild;
  while (child != null) {
    initialize(context, child, parentScope);
    child = child.nextSibling;
  }
}

function initializeSymbol(context: CheckContext, symbol: Symbol): void {
  if (symbol.state == SymbolState.INITIALIZED) {
    assert(symbol.resolvedType != null);
    return;
  }

  assert(symbol.state == SymbolState.UNINITIALIZED);
  assert(symbol.resolvedType == null);
  symbol.state = SymbolState.INITIALIZING;

  // Class
  if (symbol.kind == SymbolKind.TYPE_CLASS) {
    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;
  }

  // Enum
  else if (symbol.kind == SymbolKind.TYPE_ENUM) {
    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;
    symbol.byteSize = symbol.resolvedType.underlyingType(context).symbol.byteSize;
  }

  // Function
  else if (isFunction(symbol.kind)) {
    var returnType = symbol.node.functionReturnType();
    resolveAsType(context, returnType, symbol.scope.parent);

    var offset = 0;
    var child = symbol.node.firstChild;
    while (child != returnType) {
      assert(child.kind == NodeKind.VARIABLE);
      assert(child.symbol.kind == SymbolKind.VARIABLE_ARGUMENT);
      initializeSymbol(context, child.symbol);
      child.symbol.offset = offset;
      offset = offset + 1;
      child = child.nextSibling;
    }

    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;
  }

  // Variable
  else if (isVariable(symbol.kind)) {
    var type = symbol.node.variableType();
    var value = symbol.node.variableValue();

    if (type != null) {
      resolveAsType(context, type, symbol.scope);
      symbol.resolvedType = type.resolvedType;
    }

    else if (value != null) {
      resolveAsExpression(context, value, symbol.scope);
      symbol.resolvedType = value.resolvedType;
    }

    else {
      context.log.error(symbol.node.internalRange, String_new("Cannot create untyped variables"));
      symbol.resolvedType = context.errorType;
    }

    // Validate the variable type
    if (symbol.resolvedType == context.voidType || symbol.resolvedType == context.nullType) {
      context.log.error(symbol.node.internalRange, String_appendNew(String_append(
        String_new("Cannot create a variable with type '"),
        symbol.resolvedType.toString()),
        "'"));
      symbol.resolvedType = context.errorType;
    }

    // Resolve constant values at initialization time
    if (symbol.kind == SymbolKind.VARIABLE_CONSTANT) {
      if (symbol.resolvedType != context.errorType && !symbol.resolvedType.isInteger()) {
        context.log.error(symbol.node.internalRange, String_new("All constants must be integers for now"));
        symbol.resolvedType = context.errorType;
      }

      if (value != null) {
        resolveAsExpression(context, value, symbol.scope);
        checkConversion(context, value, symbol.resolvedTypeUnderlyingIfEnumValue(context), ConversionKind.IMPLICIT);

        // TODO: Constant folding
        if (value.kind == NodeKind.INT) {
          symbol.offset = value.intValue;
        }

        else if (value.resolvedType != context.errorType) {
          context.log.error(value.range, String_new("Constants must be initialized to a single integer for now"));
        }
      }

      // Automatically initialize enum values using the previous enum
      else if (symbol.isEnumValue()) {
        if (symbol.node.previousSibling != null) {
          var previousSymbol = symbol.node.previousSibling.symbol;
          initializeSymbol(context, previousSymbol);
          symbol.offset = previousSymbol.offset + 1;
        } else {
          symbol.offset = 0;
        }
      }

      else {
        context.log.error(symbol.node.internalRange, String_new("Constants must be initialized"));
      }
    }

    // Disallow shadowing at function scope
    if (symbol.scope.symbol == null) {
      var scope = symbol.scope.parent;
      while (scope != null) {
        var shadowed = scope.findLocal(symbol.name);
        if (shadowed != null) {
          context.log.error(symbol.node.internalRange, String_appendNew(String_append(
            String_new("The symbol '"),
            symbol.name),
            "' shadows another symbol with the same name in a parent scope"));
          break;
        }

        // Stop when we pass through a function scope
        if (scope.symbol != null) {
          break;
        }
        scope = scope.parent;
      }
    }
  }

  else {
    assert(false);
  }

  assert(symbol.resolvedType != null);
  symbol.state = SymbolState.INITIALIZED;
}

function resolveChildren(context: CheckContext, node: Node, parentScope: Scope): void {
  var child = node.firstChild;
  while (child != null) {
    resolve(context, child, parentScope);
    child = child.nextSibling;
  }
}

function resolveAsExpression(context: CheckContext, node: Node, parentScope: Scope): void {
  assert(isExpression(node));
  resolve(context, node, parentScope);

  if (node.resolvedType != context.errorType && node.isType()) {
    context.log.error(node.range, String_new("Expected expression but found type"));
    node.resolvedType = context.errorType;
  }
}

function resolveAsType(context: CheckContext, node: Node, parentScope: Scope): void {
  assert(isExpression(node));
  resolve(context, node, parentScope);

  if (node.resolvedType != context.errorType && !node.isType()) {
    context.log.error(node.range, String_new("Expected type but found expression"));
    node.resolvedType = context.errorType;
  }
}

function checkConversion(context: CheckContext, node: Node, to: Type, kind: ConversionKind): void {
  var from = node.resolvedType;
  var canCast = false;

  assert(isExpression(node));
  assert(from != null);
  assert(to != null);

  // Early-out if the types are identical or errors
  if (from == to || from == context.errorType || to == context.errorType) {
    return;
  }

  // Allow conversions from null
  if (from == context.nullType && to.isReference(context)) {
    return;
  }

  // Check integer conversions
  if (from.isInteger() && to.isInteger()) {
    var mask = to.integerBitMask();

    // Only allow lossless conversions implicitly
    if (kind == ConversionKind.EXPLICIT || from.symbol.byteSize < to.symbol.byteSize ||
        node.kind == NodeKind.INT && (to.isUnsigned()
          ? node.intValue >= 0 && node.intValue as uint <= mask
          : node.intValue >= (~mask as int >> 1) && node.intValue <= (mask >> 1) as int)) {
      return;
    }

    canCast = true;
  }

  // All other conversions are an error
  var message = String_appendNew(String_append(String_appendNew(String_append(
    String_new("Cannot convert from type '"),
    from.toString()),
    "' to type '"),
    to.toString()),
    "'");
  context.log.error(node.range, canCast ? String_appendNew(message, " without a cast") : message);

  // Prevent further errors
  node.resolvedType = context.errorType;
}

function checkStorage(context: CheckContext, target: Node): void {
  assert(isExpression(target));

  if (target.resolvedType != context.errorType && (target.kind != NodeKind.NAME && target.kind != NodeKind.DOT ||
      target.symbol != null && (!isVariable(target.symbol.kind) || target.symbol.kind == SymbolKind.VARIABLE_CONSTANT))) {
    context.log.error(target.range, String_new("Cannot store to this location"));
    target.resolvedType = context.errorType;
  }
}

function createDefaultValueForType(context: CheckContext, type: Type): Node {
  if (type.isInteger()) {
    return createInt(0);
  }

  if (type == context.boolType) {
    return createBool(false);
  }

  assert(type.isReference(context));
  return createNull();
}

function simplifyBinary(node: Node): void {
  var left = node.binaryLeft();
  var right = node.binaryRight();

  // Canonicalize addition and multiplication order
  if ((node.kind == NodeKind.ADD || node.kind == NodeKind.MULTIPLY) && left.kind == NodeKind.INT && right.kind != NodeKind.INT) {
    left.remove();
    node.appendChild(left);
    left = node.binaryLeft();
    right = node.binaryRight();
  }

  // Convert multiplication or division by a power of 2 into a shift
  if ((node.kind == NodeKind.MULTIPLY || (node.kind == NodeKind.DIVIDE || node.kind == NodeKind.REMAINDER) && node.resolvedType.isUnsigned()) &&
      right.kind == NodeKind.INT && isPositivePowerOf2(right.intValue)) {
    // Extract the shift from the value
    var shift = -1;
    var value = right.intValue;
    while (value != 0) {
      value = value >> 1;
      shift = shift + 1;
    }

    // "x * 16" => "x << 4"
    if (node.kind == NodeKind.MULTIPLY) {
      node.kind = NodeKind.SHIFT_LEFT;
      right.intValue = shift;
    }

    // "x / 16" => "x >> 4" when x is unsigned
    else if (node.kind == NodeKind.DIVIDE) {
      node.kind = NodeKind.SHIFT_RIGHT;
      right.intValue = shift;
    }

    // "x % 16" => "x & 15" when x is unsigned
    else if (node.kind == NodeKind.REMAINDER) {
      node.kind = NodeKind.BITWISE_AND;
      right.intValue = right.intValue - 1;
    }

    else {
      assert(false);
    }
  }

  // Flip addition with negation into subtraction
  else if (node.kind == NodeKind.ADD && right.kind == NodeKind.NEGATIVE) {
    var value = right.unaryValue();
    node.kind = NodeKind.SUBTRACT;
    value.remove();
    right.replaceWith(value);
  }

  // Flip addition with negative constants into subtraction
  else if (node.kind == NodeKind.ADD && right.isNegativeInteger()) {
    node.kind = NodeKind.SUBTRACT;
    right.intValue = -right.intValue;
  }
}

function binaryHasUnsignedArguments(node: Node): bool {
  var left = node.binaryLeft();
  var right = node.binaryRight();
  var leftType = left.resolvedType;
  var rightType = right.resolvedType;

  return
    leftType.isUnsigned() && rightType.isUnsigned() ||
    leftType.isUnsigned() && right.isNonNegativeInteger() ||
    left.isNonNegativeInteger() && rightType.isUnsigned();
}

function resolve(context: CheckContext, node: Node, parentScope: Scope): void {
  assert(node.kind == NodeKind.GLOBAL || parentScope != null);

  if (node.resolvedType != null) {
    return;
  }

  node.resolvedType = context.errorType;

  if (node.kind == NodeKind.GLOBAL) {
    resolveChildren(context, node, node.scope);
  }

  else if (node.kind == NodeKind.CLASS) {
    initializeSymbol(context, node.symbol);
    resolveChildren(context, node, node.scope);
    node.symbol.determineClassLayout(context);
  }

  else if (node.kind == NodeKind.ENUM) {
    initializeSymbol(context, node.symbol);
    resolveChildren(context, node, node.scope);
  }

  else if (node.kind == NodeKind.FUNCTION) {
    var body = node.functionBody();
    initializeSymbol(context, node.symbol);

    if (body != null) {
      var oldReturnType = context.currentReturnType;
      context.currentReturnType = node.functionReturnType().resolvedType;
      resolveChildren(context, body, node.scope);
      context.currentReturnType = oldReturnType;
    }
  }

  else if (node.kind == NodeKind.VARIABLE) {
    var symbol = node.symbol;
    initializeSymbol(context, symbol);

    var value = node.variableValue();
    if (value != null) {
      resolveAsExpression(context, value, parentScope);
      checkConversion(context, value, symbol.resolvedTypeUnderlyingIfEnumValue(context), ConversionKind.IMPLICIT);
    }

    else if (symbol.resolvedType != context.errorType) {
      value = createDefaultValueForType(context, symbol.resolvedType);
      resolveAsExpression(context, value, parentScope);
      node.appendChild(value);
    }
  }

  else if (node.kind == NodeKind.BREAK || node.kind == NodeKind.CONTINUE) {
    var found = false;
    var n = node;
    while (n != null) {
      if (n.kind == NodeKind.WHILE) {
        found = true;
        break;
      }
      n = n.parent;
    }
    if (!found) {
      context.log.error(node.range, String_new("Cannot use this statement outside of a loop"));
    }
  }

  else if (node.kind == NodeKind.BLOCK) {
    resolveChildren(context, node, node.scope);
  }

  else if (node.kind == NodeKind.CONSTANTS || node.kind == NodeKind.VARIABLES) {
    resolveChildren(context, node, parentScope);
  }

  else if (node.kind == NodeKind.INT) {
    node.resolvedType = node.intValue < 0 ? context.uintType : context.intType;
  }

  else if (node.kind == NodeKind.STRING) {
    node.resolvedType = context.stringType;
  }

  else if (node.kind == NodeKind.BOOL) {
    node.resolvedType = context.boolType;
  }

  else if (node.kind == NodeKind.NULL) {
    node.resolvedType = context.nullType;
  }

  else if (node.kind == NodeKind.THIS) {
    var symbol = parentScope.findNested(String_new("this"), FindNested.NORMAL);
    if (symbol == null) {
      context.log.error(node.range, String_new("Cannot use 'this' here"));
    } else {
      node.becomeSymbolReference(symbol);
    }
  }

  else if (node.kind == NodeKind.PARSE_ERROR) {
    node.resolvedType = context.errorType;
  }

  else if (node.kind == NodeKind.NAME) {
    var symbol = parentScope.findNested(node.stringValue, FindNested.NORMAL);

    if (symbol == null) {
      var message = String_appendNew(String_append(
        String_new("No symbol named '"),
        node.stringValue),
        "' here");

      // In JavaScript, "this." before instance symbols is required
      symbol = parentScope.findNested(node.stringValue, FindNested.ALLOW_INSTANCE_ERRORS);
      if (symbol != null) {
        message = String_appendNew(String_append(String_appendNew(
          message,
          ", did you mean 'this."),
          symbol.name),
          "'?");
      }

      context.log.error(node.range, message);
    }

    else if (symbol.state == SymbolState.INITIALIZING) {
      context.log.error(node.range, String_appendNew(String_append(
        String_new("Cyclic reference to symbol '"),
        node.stringValue),
        "' here"));
    }

    else if (isFunction(symbol.kind) && (node.parent.kind != NodeKind.CALL || node != node.parent.callValue())) {
      context.log.error(node.range, String_new("Bare function references are not allowed"));
    }

    else {
      initializeSymbol(context, symbol);
      node.symbol = symbol;
      node.resolvedType = symbol.resolvedType;

      // Inline constants
      if (node.symbol.kind == SymbolKind.VARIABLE_CONSTANT) {
        node.becomeIntegerConstant(node.symbol.offset);
      }
    }
  }

  else if (node.kind == NodeKind.CAST) {
    var value = node.castValue();
    var type = node.castType();
    resolveAsExpression(context, value, parentScope);
    resolveAsType(context, type, parentScope);
    checkConversion(context, value, type.resolvedType, ConversionKind.EXPLICIT);
    node.resolvedType = type.resolvedType;
  }

  else if (node.kind == NodeKind.DOT) {
    var target = node.dotTarget();
    resolve(context, target, parentScope);

    if (target.resolvedType != context.errorType) {
      if (target.isType() && target.resolvedType.isEnum() ||
          !target.isType() && target.resolvedType.isClass()) {
        var child = target.resolvedType.symbol.node.firstChild;
        var name = node.stringValue;

        // Empty names are left over from parse errors that have already been reported
        if (String_length(name) > 0) {
          node.symbol = target.resolvedType.findMember(name);

          if (node.symbol == null) {
            context.log.error(node.internalRange, String_appendNew(String_append(String_appendNew(String_append(
              String_new("No member named '"),
              name),
              "' on type '"),
              target.resolvedType.toString()),
              "'"));
          }

          else {
            initializeSymbol(context, node.symbol);
            node.resolvedType = node.symbol.resolvedType;

            // Inline constants
            if (node.symbol.kind == SymbolKind.VARIABLE_CONSTANT) {
              node.becomeIntegerConstant(node.symbol.offset);
            }
          }
        }
      }

      else {
        context.log.error(node.internalRange, String_appendNew(String_append(
          String_new("The type '"),
          target.resolvedType.toString()),
          "' has no members"));
      }
    }
  }

  else if (node.kind == NodeKind.CALL) {
    var value = node.callValue();
    resolveAsExpression(context, value, parentScope);

    if (value.resolvedType != context.errorType) {
      var symbol = value.symbol;

      // Only functions are callable
      if (symbol == null || !isFunction(symbol.kind)) {
        context.log.error(value.range, String_appendNew(String_append(
          String_new("Cannot call value of type '"),
          value.resolvedType.toString()),
          "'"));
      }

      else {
        initializeSymbol(context, symbol);

        var returnType = symbol.node.functionReturnType();
        var argumentVariable = symbol.node.functionFirstArgumentIgnoringThis();
        var argumentValue = value.nextSibling;

        // Match argument values with variables
        while (argumentVariable != returnType && argumentValue != null) {
          resolveAsExpression(context, argumentValue, parentScope);
          checkConversion(context, argumentValue, argumentVariable.symbol.resolvedType, ConversionKind.IMPLICIT);
          argumentVariable = argumentVariable.nextSibling;
          argumentValue = argumentValue.nextSibling;
        }

        // Not enough arguments?
        if (argumentVariable != returnType) {
          context.log.error(node.internalRange, String_appendNew(String_append(
            String_new("Not enough arguments for function '"),
            symbol.name),
            "'"));
        }

        // Too many arguments?
        else if (argumentValue != null) {
          while (argumentValue != null) {
            resolveAsExpression(context, argumentValue, parentScope);
            argumentValue = argumentValue.nextSibling;
          }
          context.log.error(node.internalRange, String_appendNew(String_append(
            String_new("Too many arguments for function '"),
            symbol.name),
            "'"));
        }

        // Pass the return type along
        node.resolvedType = returnType.resolvedType;
      }
    }
  }

  else if (node.kind == NodeKind.RETURN) {
    var value = node.returnValue();

    if (value != null) {
      resolveAsExpression(context, value, parentScope);

      if (context.currentReturnType != null) {
        checkConversion(context, value, context.currentReturnType, ConversionKind.IMPLICIT);
      }
    }

    else if (context.currentReturnType != null && context.currentReturnType != context.voidType) {
      context.log.error(node.range, String_new("Expected return value"));
    }
  }

  else if (node.kind == NodeKind.EMPTY) {
  }

  else if (node.kind == NodeKind.EXPRESSION) {
    resolveAsExpression(context, node.expressionValue(), parentScope);
  }

  else if (node.kind == NodeKind.WHILE) {
    var value = node.whileValue();
    var body = node.whileBody();
    resolveAsExpression(context, value, parentScope);
    checkConversion(context, value, context.boolType, ConversionKind.IMPLICIT);
    resolve(context, body, parentScope);
  }

  else if (node.kind == NodeKind.IF) {
    var value = node.ifValue();
    var yes = node.ifTrue();
    var no = node.ifFalse();
    resolveAsExpression(context, value, parentScope);
    checkConversion(context, value, context.boolType, ConversionKind.IMPLICIT);
    resolve(context, yes, parentScope);
    if (no != null) {
      resolve(context, no, parentScope);
    }
  }

  else if (node.kind == NodeKind.HOOK) {
    var value = node.hookValue();
    var yes = node.hookTrue();
    var no = node.hookFalse();
    resolveAsExpression(context, value, parentScope);
    checkConversion(context, value, context.boolType, ConversionKind.IMPLICIT);
    resolve(context, yes, parentScope);
    resolve(context, no, parentScope);
    var commonType = (yes.resolvedType == context.nullType ? no : yes).resolvedType;
    if (yes.resolvedType != commonType && (yes.resolvedType != context.nullType || !commonType.isReference(context)) &&
        no.resolvedType != commonType && (no.resolvedType != context.nullType || !commonType.isReference(context))) {
      context.log.error(spanRanges(yes.range, no.range), String_appendNew(String_append(String_appendNew(String_append(
        String_new("Type '"),
        yes.resolvedType.toString()),
        "' is not the same as type '"),
        no.resolvedType.toString()),
        "'"));
    }
    node.resolvedType = commonType;
  }

  else if (node.kind == NodeKind.ASSIGN) {
    var left = node.binaryLeft();
    var right = node.binaryRight();
    resolveAsExpression(context, left, parentScope);
    resolveAsExpression(context, right, parentScope);
    checkConversion(context, right, left.resolvedType, ConversionKind.IMPLICIT);
    checkStorage(context, left);
    node.resolvedType = left.resolvedType;
  }

  else if (
      node.kind == NodeKind.ADD || node.kind == NodeKind.SUBTRACT || node.kind == NodeKind.MULTIPLY || node.kind == NodeKind.DIVIDE || node.kind == NodeKind.REMAINDER ||
      node.kind == NodeKind.BITWISE_AND || node.kind == NodeKind.BITWISE_OR || node.kind == NodeKind.BITWISE_XOR ||
      node.kind == NodeKind.SHIFT_LEFT || node.kind == NodeKind.SHIFT_RIGHT) {
    var left = node.binaryLeft();
    var right = node.binaryRight();

    resolveAsExpression(context, left, parentScope);
    resolveAsExpression(context, right, parentScope);

    var commonType = binaryHasUnsignedArguments(node) ? context.uintType : context.intType;
    if (commonType == context.uintType) {
      node.flags = node.flags | NODE_FLAG_UNSIGNED_OPERATOR;
    }
    checkConversion(context, left, commonType, ConversionKind.IMPLICIT);
    checkConversion(context, right, commonType, ConversionKind.IMPLICIT);
    node.resolvedType = commonType;

    // Automatically fold constants
    if (left.kind == NodeKind.INT && right.kind == NodeKind.INT) {
      var inputLeft = left.intValue;
      var inputRight = right.intValue;
      var output = 0;
      if (node.kind == NodeKind.ADD) output = inputLeft + inputRight;
      else if (node.kind == NodeKind.BITWISE_AND) output = inputLeft & inputRight;
      else if (node.kind == NodeKind.BITWISE_OR) output = inputLeft | inputRight;
      else if (node.kind == NodeKind.BITWISE_XOR) output = inputLeft ^ inputRight;
      else if (node.kind == NodeKind.DIVIDE) output = inputLeft / inputRight;
      else if (node.kind == NodeKind.MULTIPLY) output = inputLeft * inputRight;
      else if (node.kind == NodeKind.REMAINDER) output = inputLeft % inputRight;
      else if (node.kind == NodeKind.SHIFT_LEFT) output = inputLeft << inputRight;
      else if (node.kind == NodeKind.SHIFT_RIGHT) output = inputLeft >> inputRight;
      else if (node.kind == NodeKind.SUBTRACT) output = inputLeft - inputRight;
      else return;
      node.becomeIntegerConstant(output);
    }

    else {
      simplifyBinary(node);
    }
  }

  else if (
      node.kind == NodeKind.LESS_THAN || node.kind == NodeKind.LESS_THAN_EQUAL ||
      node.kind == NodeKind.GREATER_THAN || node.kind == NodeKind.GREATER_THAN_EQUAL) {
    var left = node.binaryLeft();
    var right = node.binaryRight();
    resolveAsExpression(context, left, parentScope);
    resolveAsExpression(context, right, parentScope);
    var leftType = left.resolvedType;
    var rightType = right.resolvedType;
    var expectedType =
      leftType == rightType && leftType.isEnum() ? leftType :
      binaryHasUnsignedArguments(node) ? context.uintType :
      context.intType;
    if (expectedType == context.uintType) {
      node.flags = node.flags | NODE_FLAG_UNSIGNED_OPERATOR;
    }
    checkConversion(context, left, expectedType, ConversionKind.IMPLICIT);
    checkConversion(context, right, expectedType, ConversionKind.IMPLICIT);
    node.resolvedType = context.boolType;
  }

  else if (node.kind == NodeKind.LOGICAL_OR || node.kind == NodeKind.LOGICAL_AND) {
    var left = node.binaryLeft();
    var right = node.binaryRight();
    resolveAsExpression(context, left, parentScope);
    resolveAsExpression(context, right, parentScope);
    checkConversion(context, left, context.boolType, ConversionKind.IMPLICIT);
    checkConversion(context, right, context.boolType, ConversionKind.IMPLICIT);
    node.resolvedType = context.boolType;
  }

  else if (node.kind == NodeKind.EQUAL || node.kind == NodeKind.NOT_EQUAL) {
    var left = node.binaryLeft();
    var right = node.binaryRight();
    resolveAsExpression(context, left, parentScope);
    resolveAsExpression(context, right, parentScope);
    node.resolvedType = context.boolType;

    var leftType = left.resolvedType;
    var rightType = right.resolvedType;

    if (leftType != context.errorType && rightType != context.errorType && (leftType == rightType ? leftType == context.voidType :
        (leftType != context.nullType || !rightType.isReference(context)) &&
        (rightType != context.nullType || !leftType.isReference(context)) &&
        (!leftType.isUnsigned() || !right.isNonNegativeInteger()) &&
        (!rightType.isUnsigned() || !left.isNonNegativeInteger()))) {
      context.log.error(node.range, String_appendNew(String_append(String_appendNew(String_append(
        String_new("Cannot compare type '"),
        leftType.toString()),
        "' with type '"),
        rightType.toString()),
        "'"));
    }
  }

  else if (node.kind == NodeKind.COMPLEMENT || node.kind == NodeKind.NEGATIVE || node.kind == NodeKind.POSITIVE) {
    var value = node.unaryValue();
    resolveAsExpression(context, value, parentScope);
    var expectedType = value.resolvedType.isUnsigned() ? context.uintType : context.intType;
    checkConversion(context, value, expectedType, ConversionKind.IMPLICIT);
    node.resolvedType = node.kind == NodeKind.NEGATIVE ? context.intType : expectedType;

    // Automatically fold constants
    if (value.kind == NodeKind.INT) {
      var input = value.intValue;
      var output = input;
      if (node.kind == NodeKind.COMPLEMENT) output = ~input;
      else if (node.kind == NodeKind.NEGATIVE) output = -input;
      node.becomeIntegerConstant(output);
    }
  }

  else if (node.kind == NodeKind.POSTFIX_DECREMENT || node.kind == NodeKind.POSTFIX_INCREMENT ||
      node.kind == NodeKind.PREFIX_DECREMENT || node.kind == NodeKind.PREFIX_INCREMENT) {
    context.log.error(node.range, String_new("This operator is currently unsupported"));
  }

  else if (node.kind == NodeKind.NOT) {
    var value = node.unaryValue();
    resolveAsExpression(context, value, parentScope);
    checkConversion(context, value, context.boolType, ConversionKind.IMPLICIT);
    node.resolvedType = context.boolType;
  }

  else if (node.kind == NodeKind.NEW) {
    var type = node.newType();
    resolveAsType(context, type, parentScope);

    if (type.resolvedType != context.errorType) {
      if (!type.resolvedType.isClass()) {
        context.log.error(type.range, String_appendNew(String_append(
          String_new("Cannot construct type '"),
          type.resolvedType.toString()),
          "'"));
      }

      else {
        node.resolvedType = type.resolvedType;
      }
    }
  }

  else {
    assert(false);
  }
}

function check(global: Node, log: Log): CheckContext {
  var context = new CheckContext();
  context.log = log;
  initialize(context, global, null);
  resolve(context, global, null);
  return context;
}
