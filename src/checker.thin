enum SymbolKind {
  TYPE_CLASS,
  TYPE_ENUM,
  TYPE_GLOBAL,
  TYPE_NATIVE,

  FUNCTION_INSTANCE,
  FUNCTION_GLOBAL,

  VARIABLE_ARGUMENT,
  VARIABLE_CONSTANT,
  VARIABLE_INSTANCE,
  VARIABLE_LOCAL,
}

function isType(kind: SymbolKind): bool {
  return kind >= SymbolKind.TYPE_CLASS && kind <= SymbolKind.TYPE_NATIVE;
}

function isFunction(kind: SymbolKind): bool {
  return kind >= SymbolKind.FUNCTION_INSTANCE && kind <= SymbolKind.FUNCTION_GLOBAL;
}

function isVariable(kind: SymbolKind): bool {
  return kind >= SymbolKind.VARIABLE_ARGUMENT && kind <= SymbolKind.VARIABLE_LOCAL;
}

enum SymbolState {
  UNINITIALIZED,
  INITIALIZING,
  INITIALIZED,
}

class Symbol {
  kind: SymbolKind;
  name: String;
  node: Node;
  range: Range;
  scope: Scope;
  resolvedType: Type;
  next: Symbol;
  state: SymbolState;

  // The "offset" variable is used to store kind-specific information
  //
  //   TYPE_CLASS: Object size
  //   TYPE_ENUM: N/A
  //   TYPE_GLOBAL: N/A
  //   TYPE_NATIVE: N/A
  //
  //   FUNCTION_INSTANCE: N/A
  //   FUNCTION_GLOBAL: N/A
  //
  //   VARIABLE_ARGUMENT: Argument index
  //   VARIABLE_CONSTANT: Integer constant value
  //   VARIABLE_INSTANCE: Instance offset
  //   VARIABLE_LOCAL: N/A
  //
  offset: int;

  isEnumValue(): bool {
    return this.node.parent.kind == NodeKind.ENUM;
  }

  resolvedTypeIntIfEnumValue(context: CheckContext): Type {
    if (this.isEnumValue()) {
      return context.intType;
    }
    return this.resolvedType;
  }
}

function isExternSymbol(symbol: Symbol): bool {
  return (symbol.node.flags & NODE_FLAG_EXTERN) != 0;
}

class Scope {
  parent: Scope;
  symbol: Symbol;
  firstSymbol: Symbol;
  lastSymbol: Symbol;
}

class Type {
  symbol: Symbol;

  isClass(): bool {
    return this.symbol.kind == SymbolKind.TYPE_CLASS;
  }

  isEnum(): bool {
    return this.symbol.kind == SymbolKind.TYPE_ENUM;
  }

  isInteger(context: CheckContext): bool {
    return this == context.intType || this.isEnum();
  }
}

function typeIsReference(context: CheckContext, type: Type): bool {
  return type.isClass() || type == context.stringType;
}

function typeToString(type: Type): String {
  return type.symbol.name;
}

class CheckContext {
  log: Log;
  currentReturnType: Type;
  boolType: Type;
  errorType: Type;
  intType: Type;
  nullType: Type;
  stringType: Type;
  voidType: Type;
}

function findLocal(scope: Scope, name: String): Symbol {
  var symbol = scope.firstSymbol;
  while (symbol != null) {
    if (String_equal(symbol.name, name)) {
      return symbol;
    }
    symbol = symbol.next;
  }
  return null;
}

function findMember(type: Type, name: String): Symbol {
  var child = type.symbol.node.firstChild;

  while (child != null) {
    assert(child.kind == NodeKind.VARIABLE || child.kind == NodeKind.FUNCTION);

    if (String_equal(child.symbol.name, name)) {
      return child.symbol;
    }

    child = child.nextSibling;
  }

  return null;
}

enum FindNested {
  NORMAL,
  ALLOW_INSTANCE_ERRORS,
}

function findNested(scope: Scope, name: String, mode: FindNested): Symbol {
  while (scope != null) {
    if (scope.symbol == null || scope.symbol.kind != SymbolKind.TYPE_CLASS || mode == FindNested.ALLOW_INSTANCE_ERRORS) {
      var local = findLocal(scope, name);
      if (local != null) {
        return local;
      }
    }
    scope = scope.parent;
  }
  return null;
}

function define(log: Log, scope: Scope, symbol: Symbol): bool {
  var existing = findLocal(scope, symbol.name);
  if (existing != null) {
    log.error(symbol.range, String_appendNew(String_append(String_new("Duplicate symbol '"), symbol.name), "'"));
    return false;
  }

  if (scope.firstSymbol == null) scope.firstSymbol = symbol;
  else scope.lastSymbol.next = symbol;
  scope.lastSymbol = symbol;

  return true;
}

function defineNativeType(log: Log, scope: Scope, name: string): Type {
  var symbol = new Symbol();
  symbol.kind = SymbolKind.TYPE_NATIVE;
  symbol.name = String_new(name);
  symbol.resolvedType = new Type();
  symbol.resolvedType.symbol = symbol;
  symbol.state = SymbolState.INITIALIZED;

  define(log, scope, symbol);

  return symbol.resolvedType;
}

function addScopeToSymbol(symbol: Symbol, parentScope: Scope): void {
  var scope = new Scope();
  scope.parent = parentScope;
  scope.symbol = symbol;
  symbol.scope = scope;
}

function linkSymbolToNode(symbol: Symbol, node: Node): void {
  node.symbol = symbol;
  node.scope = symbol.scope;
  symbol.range = node.internalRange != null ? node.internalRange : node.range;
  symbol.node = node;
}

function initialize(context: CheckContext, node: Node, parentScope: Scope): void {
  if (node.parent != null) {
    var kind = node.kind;
    var parentKind = node.parent.kind;

    // Validate node placement
    if (kind != NodeKind.VARIABLE && (kind != NodeKind.FUNCTION || parentKind != NodeKind.CLASS) && (parentKind == NodeKind.GLOBAL) !=
        (kind == NodeKind.CLASS || kind == NodeKind.ENUM || kind == NodeKind.FUNCTION || kind == NodeKind.CONSTANTS)) {
      context.log.error(node.range, String_new("This statement is not allowed here"));
    }
  }

  // Global
  if (node.kind == NodeKind.GLOBAL) {
    assert(parentScope == null);

    var symbol = new Symbol();
    symbol.kind = SymbolKind.TYPE_GLOBAL;
    symbol.name = String_new("<global>");
    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;
    symbol.state = SymbolState.INITIALIZED;
    addScopeToSymbol(symbol, parentScope);
    linkSymbolToNode(symbol, node);

    context.boolType = defineNativeType(context.log, symbol.scope, "bool");
    context.errorType = defineNativeType(context.log, symbol.scope, "<error>");
    context.intType = defineNativeType(context.log, symbol.scope, "int");
    context.nullType = defineNativeType(context.log, symbol.scope, "null");
    context.stringType = defineNativeType(context.log, symbol.scope, "string");
    context.voidType = defineNativeType(context.log, symbol.scope, "void");

    parentScope = symbol.scope;
  }

  // Class
  else if (node.kind == NodeKind.CLASS || node.kind == NodeKind.ENUM) {
    var symbol = new Symbol();
    symbol.kind = node.kind == NodeKind.CLASS ? SymbolKind.TYPE_CLASS : SymbolKind.TYPE_ENUM;
    symbol.name = node.stringValue;
    addScopeToSymbol(symbol, parentScope);
    linkSymbolToNode(symbol, node);

    define(context.log, parentScope, symbol);

    parentScope = symbol.scope;
  }

  // Function
  else if (node.kind == NodeKind.FUNCTION) {
    var symbol = new Symbol();
    symbol.kind =
      node.parent.kind == NodeKind.CLASS ? SymbolKind.FUNCTION_INSTANCE :
      SymbolKind.FUNCTION_GLOBAL;
    symbol.name = node.stringValue;
    addScopeToSymbol(symbol, parentScope);
    linkSymbolToNode(symbol, node);

    define(context.log, parentScope, symbol);

    parentScope = symbol.scope;

    // All instance functions have a special "this" type
    if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
      var parent = node.parent.symbol;
      assert(parent.kind == SymbolKind.TYPE_CLASS);
      initializeSymbol(context, parent);
      node.insertChildBefore(node.firstChild, createVariable(String_new("this"), createType(parent.resolvedType), null));
    }
  }

  // Variable
  else if (node.kind == NodeKind.VARIABLE) {
    var symbol = new Symbol();
    symbol.kind =
      node.parent.kind == NodeKind.CLASS ? SymbolKind.VARIABLE_INSTANCE :
      node.parent.kind == NodeKind.FUNCTION ? SymbolKind.VARIABLE_ARGUMENT :
      node.parent.kind == NodeKind.CONSTANTS || node.parent.kind == NodeKind.ENUM ? SymbolKind.VARIABLE_CONSTANT :
      SymbolKind.VARIABLE_LOCAL;
    symbol.name = node.stringValue;
    symbol.scope = parentScope;
    linkSymbolToNode(symbol, node);

    define(context.log, parentScope, symbol);
  }

  // Block
  else if (node.kind == NodeKind.BLOCK) {
    if (node.parent.kind != NodeKind.FUNCTION) {
      var scope = new Scope();
      scope.parent = parentScope;
      parentScope = scope;
    }

    node.scope = parentScope;
  }

  // Children
  var child = node.firstChild;
  while (child != null) {
    initialize(context, child, parentScope);
    child = child.nextSibling;
  }
}

function initializeSymbol(context: CheckContext, symbol: Symbol): void {
  if (symbol.state == SymbolState.INITIALIZED) {
    assert(symbol.resolvedType != null);
    return;
  }

  assert(symbol.state == SymbolState.UNINITIALIZED);
  assert(symbol.resolvedType == null);
  symbol.state = SymbolState.INITIALIZING;

  // Class
  if (symbol.kind == SymbolKind.TYPE_CLASS) {
    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;
  }

  // Enum
  else if (symbol.kind == SymbolKind.TYPE_ENUM) {
    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;
  }

  // Function
  else if (isFunction(symbol.kind)) {
    var returnType = symbol.node.functionReturnType();
    resolveAsType(context, returnType, symbol.scope.parent);

    var offset = 0;
    var child = symbol.node.firstChild;
    while (child != returnType) {
      assert(child.kind == NodeKind.VARIABLE);
      assert(child.symbol.kind == SymbolKind.VARIABLE_ARGUMENT);
      initializeSymbol(context, child.symbol);
      child.symbol.offset = offset;
      offset = offset + 1;
      child = child.nextSibling;
    }

    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;
  }

  // Variable
  else if (isVariable(symbol.kind)) {
    var type = symbol.node.variableType();
    var value = symbol.node.variableValue();

    if (type != null) {
      resolveAsType(context, type, symbol.scope);
      symbol.resolvedType = type.resolvedType;
    }

    else if (value != null) {
      resolveAsExpression(context, value, symbol.scope);
      symbol.resolvedType = value.resolvedType;
    }

    else {
      context.log.error(symbol.node.internalRange, String_new("Cannot create untyped variables"));
      symbol.resolvedType = context.errorType;
    }

    // Validate the variable type
    if (symbol.resolvedType == context.voidType || symbol.resolvedType == context.nullType) {
      context.log.error(symbol.node.internalRange, String_appendNew(String_append(
        String_new("Cannot create a variable with type '"),
        typeToString(symbol.resolvedType)),
        "'"));
      symbol.resolvedType = context.errorType;
    }

    // Resolve constant values at initialization time
    if (symbol.kind == SymbolKind.VARIABLE_CONSTANT) {
      if (symbol.resolvedType != context.errorType && !symbol.resolvedType.isInteger(context)) {
        context.log.error(symbol.node.internalRange, String_new("All constants must be integers for now"));
        symbol.resolvedType = context.errorType;
      }

      if (value != null) {
        resolveAsExpression(context, value, symbol.scope);
        checkConversion(context, value, symbol.resolvedTypeIntIfEnumValue(context));

        // TODO: Constant folding
        if (value.kind == NodeKind.INT) {
          symbol.offset = value.intValue;
        }

        else {
          context.log.error(value.range, String_new("Constants must be initialized to a single integer for now"));
        }
      }

      // Automatically initialize enum values using the previous enum
      else if (symbol.isEnumValue()) {
        if (symbol.node.previousSibling != null) {
          var previousSymbol = symbol.node.previousSibling.symbol;
          initializeSymbol(context, previousSymbol);
          symbol.offset = previousSymbol.offset + 1;
        } else {
          symbol.offset = 0;
        }
      }

      else {
        context.log.error(symbol.node.internalRange, String_new("Constants must be initialized"));
      }
    }

    // Disallow shadowing at function scope
    if (symbol.scope.symbol == null) {
      var scope = symbol.scope.parent;
      while (scope != null) {
        var shadowed = findLocal(scope, symbol.name);
        if (shadowed != null) {
          context.log.error(symbol.node.internalRange, String_appendNew(String_append(
            String_new("The symbol '"),
            symbol.name),
            "' shadows another symbol with the same name in a parent scope"));
          break;
        }

        // Stop when we pass through a function scope
        if (scope.symbol != null) {
          break;
        }
        scope = scope.parent;
      }
    }
  }

  else {
    assert(false);
  }

  assert(symbol.resolvedType != null);
  symbol.state = SymbolState.INITIALIZED;
}

function resolveChildren(context: CheckContext, node: Node, parentScope: Scope): void {
  var child = node.firstChild;
  while (child != null) {
    resolve(context, child, parentScope);
    child = child.nextSibling;
  }
}

function resolveAsExpression(context: CheckContext, node: Node, parentScope: Scope): void {
  assert(isExpression(node));
  resolve(context, node, parentScope);

  if (node.resolvedType != context.errorType && node.isType()) {
    context.log.error(node.range, String_new("Expected expression but found type"));
    node.resolvedType = context.errorType;
  }
}

function resolveAsType(context: CheckContext, node: Node, parentScope: Scope): void {
  assert(isExpression(node));
  resolve(context, node, parentScope);

  if (node.resolvedType != context.errorType && !node.isType()) {
    context.log.error(node.range, String_new("Expected type but found expression"));
    node.resolvedType = context.errorType;
  }
}

function checkConversion(context: CheckContext, from: Node, to: Type): void {
  assert(isExpression(from));
  assert(to != null);

  if (from.resolvedType != context.errorType && to != context.errorType &&
      from.resolvedType != to && (from.resolvedType != context.nullType || !typeIsReference(context, to))) {
    context.log.error(from.range, String_appendNew(String_append(String_appendNew(String_append(
      String_new("Cannot convert from type '"),
      typeToString(from.resolvedType)),
      "' to type '"),
      typeToString(to)),
      "'"));
    from.resolvedType = context.errorType;
  }
}

function checkStorage(context: CheckContext, target: Node): void {
  assert(isExpression(target));

  if (target.resolvedType != context.errorType && (target.kind != NodeKind.NAME && target.kind != NodeKind.DOT ||
      target.symbol != null && (!isVariable(target.symbol.kind) || target.symbol.kind == SymbolKind.VARIABLE_CONSTANT))) {
    context.log.error(target.range, String_new("Cannot store to this location"));
    target.resolvedType = context.errorType;
  }
}

function resolveUnary(context: CheckContext, node: Node, parentScope: Scope, expectedType: Type): void {
  var value = node.unaryValue();
  resolveAsExpression(context, value, parentScope);
  checkConversion(context, value, expectedType);
  node.resolvedType = expectedType;
}

function resolveBinary(context: CheckContext, node: Node, parentScope: Scope): void {
  var left = node.binaryLeft();
  var right = node.binaryRight();
  resolveAsExpression(context, left, parentScope);
  resolveAsExpression(context, right, parentScope);
}

function checkBinary(context: CheckContext, node: Node, expectedType: Type, resultType: Type): void {
  var left = node.binaryLeft();
  var right = node.binaryRight();
  checkConversion(context, left, expectedType);
  checkConversion(context, right, expectedType);
  node.resolvedType = resultType;
}

function createDefaultValueForType(context: CheckContext, type: Type): Node {
  if (type.isInteger(context)) {
    return createInt(0);
  }

  if (type == context.boolType) {
    return createBool(false);
  }

  assert(typeIsReference(context, type));
  return createNull();
}

function resolve(context: CheckContext, node: Node, parentScope: Scope): void {
  assert(node.kind == NodeKind.GLOBAL || parentScope != null);

  if (node.resolvedType != null) {
    return;
  }

  node.resolvedType = context.errorType;

  if (node.kind == NodeKind.GLOBAL) {
    resolveChildren(context, node, node.scope);
  }

  else if (node.kind == NodeKind.CLASS) {
    initializeSymbol(context, node.symbol);
    resolveChildren(context, node, node.scope);

    // Determine class layout
    var offset = 0;
    var child = node.firstChild;
    while (child != null) {
      if (child.kind == NodeKind.VARIABLE) {
        child.symbol.offset = offset;
        offset = offset + 4;
      }
      child = child.nextSibling;
    }
    node.symbol.offset = offset > 0 ? offset : 1;
  }

  else if (node.kind == NodeKind.ENUM) {
    initializeSymbol(context, node.symbol);
    resolveChildren(context, node, node.scope);
  }

  else if (node.kind == NodeKind.FUNCTION) {
    var body = node.functionBody();
    initializeSymbol(context, node.symbol);

    if (body != null) {
      var oldReturnType = context.currentReturnType;
      context.currentReturnType = node.functionReturnType().resolvedType;
      resolveChildren(context, body, node.scope);
      context.currentReturnType = oldReturnType;
    }
  }

  else if (node.kind == NodeKind.VARIABLE) {
    var symbol = node.symbol;
    initializeSymbol(context, symbol);

    var value = node.variableValue();
    if (value != null) {
      resolveAsExpression(context, value, parentScope);
      checkConversion(context, value, symbol.resolvedTypeIntIfEnumValue(context));
    }

    else {
      node.appendChild(createDefaultValueForType(context, symbol.resolvedType));
    }
  }

  else if (node.kind == NodeKind.BREAK || node.kind == NodeKind.CONTINUE) {
    var found = false;
    var n = node;
    while (n != null) {
      if (n.kind == NodeKind.WHILE) {
        found = true;
        break;
      }
      n = n.parent;
    }
    if (!found) {
      context.log.error(node.range, String_new("Cannot use this statement outside of a loop"));
    }
  }

  else if (node.kind == NodeKind.BLOCK) {
    resolveChildren(context, node, node.scope);
  }

  else if (node.kind == NodeKind.CONSTANTS || node.kind == NodeKind.VARIABLES) {
    resolveChildren(context, node, parentScope);
  }

  else if (node.kind == NodeKind.INT) {
    node.resolvedType = context.intType;
  }

  else if (node.kind == NodeKind.STRING) {
    node.resolvedType = context.stringType;
  }

  else if (node.kind == NodeKind.BOOL) {
    node.resolvedType = context.boolType;
  }

  else if (node.kind == NodeKind.NULL) {
    node.resolvedType = context.nullType;
  }

  else if (node.kind == NodeKind.THIS) {
    var symbol = findNested(parentScope, String_new("this"), FindNested.NORMAL);
    if (symbol == null) {
      context.log.error(node.range, String_new("Cannot use 'this' here"));
    } else {
      node.becomeSymbolReference(symbol);
    }
  }

  else if (node.kind == NodeKind.NAME) {
    var symbol = findNested(parentScope, node.stringValue, FindNested.NORMAL);

    if (symbol == null) {
      var message = String_appendNew(String_append(
        String_new("No symbol named '"),
        node.stringValue),
        "' here");

      // In JavaScript, "this." before instance symbols is required
      symbol = findNested(parentScope, node.stringValue, FindNested.ALLOW_INSTANCE_ERRORS);
      if (symbol != null) {
        message = String_appendNew(String_append(String_appendNew(
          message,
          ", did you mean 'this."),
          symbol.name),
          "'?");
      }

      context.log.error(node.range, message);
    }

    else if (symbol.state == SymbolState.INITIALIZING) {
      context.log.error(node.range, String_appendNew(String_append(
        String_new("Cyclic reference to symbol '"),
        node.stringValue),
        "' here"));
    }

    else if (isFunction(symbol.kind) && (node.parent.kind != NodeKind.CALL || node != node.parent.callValue())) {
      context.log.error(node.range, String_new("Bare function references are not allowed"));
    }

    else {
      initializeSymbol(context, symbol);
      node.symbol = symbol;
      node.resolvedType = symbol.resolvedType;

      // Inline constants
      if (node.symbol.kind == SymbolKind.VARIABLE_CONSTANT) {
        node.becomeIntegerConstant(node.symbol.offset);
      }
    }
  }

  else if (node.kind == NodeKind.DOT) {
    var target = node.dotTarget();
    resolve(context, target, parentScope);

    if (target.resolvedType != context.errorType) {
      if (target.isType() && target.resolvedType.isEnum() ||
          !target.isType() && target.resolvedType.isClass()) {
        var child = target.resolvedType.symbol.node.firstChild;
        node.symbol = findMember(target.resolvedType, node.stringValue);

        if (node.symbol == null) {
          context.log.error(node.internalRange, String_appendNew(String_append(String_appendNew(String_append(
            String_new("No member named '"),
            node.stringValue),
            "' on type '"),
            typeToString(target.resolvedType)),
            "'"));
        }

        else {
          initializeSymbol(context, node.symbol);
          node.resolvedType = node.symbol.resolvedType;

          // Inline constants
          if (node.symbol.kind == SymbolKind.VARIABLE_CONSTANT) {
            node.becomeIntegerConstant(node.symbol.offset);
          }
        }
      }

      else {
        context.log.error(node.internalRange, String_appendNew(String_append(
          String_new("The type '"),
          typeToString(target.resolvedType)),
          "' has no members"));
      }
    }
  }

  else if (node.kind == NodeKind.CALL) {
    var value = node.callValue();
    resolveAsExpression(context, value, parentScope);

    if (value.resolvedType != context.errorType) {
      var symbol = value.symbol;

      // Only functions are callable
      if (symbol == null || !isFunction(symbol.kind)) {
        context.log.error(value.range, String_appendNew(String_append(
          String_new("Cannot call value of type '"),
          typeToString(value.resolvedType)),
          "'"));
      }

      else {
        initializeSymbol(context, symbol);

        var returnType = symbol.node.functionReturnType();
        var argumentVariable = symbol.node.functionFirstArgumentIgnoringThis();
        var argumentValue = value.nextSibling;

        // Match argument values with variables
        while (argumentVariable != returnType && argumentValue != null) {
          resolveAsExpression(context, argumentValue, parentScope);
          checkConversion(context, argumentValue, argumentVariable.symbol.resolvedType);
          argumentVariable = argumentVariable.nextSibling;
          argumentValue = argumentValue.nextSibling;
        }

        // Not enough arguments?
        if (argumentVariable != returnType) {
          context.log.error(node.internalRange, String_appendNew(String_append(
            String_new("Not enough arguments for function '"),
            symbol.name),
            "'"));
        }

        // Too many arguments?
        else if (argumentValue != null) {
          while (argumentValue != null) {
            resolveAsExpression(context, argumentValue, parentScope);
            argumentValue = argumentValue.nextSibling;
          }
          context.log.error(node.internalRange, String_appendNew(String_append(
            String_new("Too many arguments for function '"),
            symbol.name),
            "'"));
        }

        // Pass the return type along
        node.resolvedType = returnType.resolvedType;
      }
    }
  }

  else if (node.kind == NodeKind.RETURN) {
    var value = node.returnValue();

    if (value != null) {
      resolveAsExpression(context, value, parentScope);

      if (context.currentReturnType != null) {
        checkConversion(context, value, context.currentReturnType);
      }
    }

    else if (context.currentReturnType != null && context.currentReturnType != context.voidType) {
      context.log.error(node.range, String_new("Expected return value"));
    }
  }

  else if (node.kind == NodeKind.EMPTY) {
  }

  else if (node.kind == NodeKind.EXPRESSION) {
    resolveAsExpression(context, node.expressionValue(), parentScope);
  }

  else if (node.kind == NodeKind.WHILE) {
    var value = node.whileValue();
    var body = node.whileBody();
    resolveAsExpression(context, value, parentScope);
    checkConversion(context, value, context.boolType);
    resolve(context, body, parentScope);
  }

  else if (node.kind == NodeKind.IF) {
    var value = node.ifValue();
    var yes = node.ifTrue();
    var no = node.ifFalse();
    resolveAsExpression(context, value, parentScope);
    checkConversion(context, value, context.boolType);
    resolve(context, yes, parentScope);
    if (no != null) {
      resolve(context, no, parentScope);
    }
  }

  else if (node.kind == NodeKind.HOOK) {
    var value = node.hookValue();
    var yes = node.hookTrue();
    var no = node.hookFalse();
    resolveAsExpression(context, value, parentScope);
    checkConversion(context, value, context.boolType);
    resolve(context, yes, parentScope);
    resolve(context, no, parentScope);
    var commonType = (yes.resolvedType == context.nullType ? no : yes).resolvedType;
    if (yes.resolvedType != commonType && (yes.resolvedType != context.nullType || !typeIsReference(context, commonType)) &&
        no.resolvedType != commonType && (no.resolvedType != context.nullType || !typeIsReference(context, commonType))) {
      context.log.error(spanRanges(yes.range, no.range), String_appendNew(String_append(String_appendNew(String_append(
        String_new("Type '"),
        typeToString(yes.resolvedType)),
        "' is not the same as type '"),
        typeToString(no.resolvedType)),
        "'"));
    }
    node.resolvedType = commonType;
  }

  else if (node.kind == NodeKind.ASSIGN) {
    var left = node.binaryLeft();
    var right = node.binaryRight();
    resolveAsExpression(context, left, parentScope);
    resolveAsExpression(context, right, parentScope);
    checkConversion(context, right, left.resolvedType);
    checkStorage(context, left);
    node.resolvedType = left.resolvedType;
  }

  else if (
      node.kind == NodeKind.ADD || node.kind == NodeKind.SUBTRACT || node.kind == NodeKind.MULTIPLY || node.kind == NodeKind.DIVIDE ||
      node.kind == NodeKind.BITWISE_AND || node.kind == NodeKind.BITWISE_OR || node.kind == NodeKind.BITWISE_XOR ||
      node.kind == NodeKind.SHIFT_LEFT || node.kind == NodeKind.SHIFT_RIGHT) {
    resolveBinary(context, node, parentScope);
    checkBinary(context, node, context.intType, context.intType);
  }

  else if (
      node.kind == NodeKind.LESS_THAN || node.kind == NodeKind.LESS_THAN_EQUAL ||
      node.kind == NodeKind.GREATER_THAN || node.kind == NodeKind.GREATER_THAN_EQUAL) {
    var left = node.binaryLeft();
    var right = node.binaryRight();
    resolveAsExpression(context, left, parentScope);
    resolveAsExpression(context, right, parentScope);
    var expectedType = left.resolvedType == right.resolvedType && left.resolvedType.isInteger(context) ? left.resolvedType : context.intType;
    checkConversion(context, left, expectedType);
    checkConversion(context, right, expectedType);
  }

  else if (node.kind == NodeKind.LOGICAL_OR || node.kind == NodeKind.LOGICAL_AND) {
    resolveBinary(context, node, parentScope);
    checkBinary(context, node, context.boolType, context.boolType);
  }

  else if (node.kind == NodeKind.EQUAL || node.kind == NodeKind.NOT_EQUAL) {
    var left = node.binaryLeft();
    var right = node.binaryRight();
    resolveBinary(context, node, parentScope);
    node.resolvedType = context.boolType;

    var leftType = left.resolvedType;
    var rightType = right.resolvedType;

    if (leftType != context.errorType && rightType != context.errorType && (leftType == rightType ? leftType == context.voidType :
        (leftType != context.nullType || !typeIsReference(context, rightType)) &&
        (rightType != context.nullType || !typeIsReference(context, leftType)))) {
      context.log.error(node.range, String_appendNew(String_append(String_appendNew(String_append(
        String_new("Cannot compare type '"),
        typeToString(leftType)),
        "' with type '"),
        typeToString(rightType)),
        "'"));
    }
  }

  else if (node.kind == NodeKind.COMPLEMENT || node.kind == NodeKind.NEGATIVE || node.kind == NodeKind.POSITIVE) {
    resolveUnary(context, node, parentScope, context.intType);
  }

  else if (node.kind == NodeKind.NOT) {
    resolveUnary(context, node, parentScope, context.boolType);
  }

  else if (node.kind == NodeKind.NEW) {
    var type = node.newType();
    resolveAsType(context, type, parentScope);

    if (type.resolvedType != context.errorType) {
      if (!type.resolvedType.isClass()) {
        context.log.error(type.range, String_appendNew(String_append(
          String_new("Cannot construct type '"),
          typeToString(type.resolvedType)),
          "'"));
      }

      else {
        node.resolvedType = type.resolvedType;
      }
    }
  }

  else {
    assert(false);
  }
}

function check(global: Node, log: Log): CheckContext {
  var context = new CheckContext();
  context.log = log;
  initialize(context, global, null);
  resolve(context, global, null);
  return context;
}
