class PreprocessorFlag {
  isDefined: bool;
  name: string;
  next: PreprocessorFlag;
}

// This preprocessor implements the flag-only conditional behavior from C#.
// There are two scopes for flags: global-level and file-level. This is stored
// using an ever-growing linked list of PreprocessorFlag objects that turn a
// flag either on or off. That way file-level state can just reference the
// memory of the global-level state and the global-level state can easily be
// restored after parsing a file just by restoring the pointer.
class Preprocessor {
  firstFlag: PreprocessorFlag;
  isDefineAndUndefAllowed: bool;
  previous: Token;
  current: Token;
  log: Log;

  peek(kind: TokenKind): bool {
    return this.current.kind == kind;
  }

  eat(kind: TokenKind): bool {
    if (this.peek(kind)) {
      this.advance();
      return true;
    }

    return false;
  }

  advance(): void {
    if (!this.peek(TokenKind.END_OF_FILE)) {
      this.previous = this.current;
      this.current = this.current.next;
    }
  }

  unexpectedToken(): void {
    this.log.error(this.current.range, StringBuilder_new()
      .append("Unexpected ")
      .append(tokenToString(this.current.kind))
      .finish());
  }

  expect(kind: TokenKind): bool {
    if (!this.peek(kind)) {
      this.log.error(this.current.range, StringBuilder_new()
        .append("Expected ")
        .append(tokenToString(kind))
        .append(" but found ")
        .append(tokenToString(this.current.kind))
        .finish());
      return false;
    }

    this.advance();
    return true;
  }

  removeTokensFrom(before: Token): void {
    before.next = this.current;
    this.previous = before;
  }

  isDefined(name: string): bool {
    var flag = this.firstFlag;
    while (flag != null) {
      if (string_equals(flag.name, name)) {
        return flag.isDefined;
      }
      flag = flag.next;
    }
    return false;
  }

  define(name: string, isDefined: bool): void {
    var flag = new PreprocessorFlag();
    flag.isDefined = isDefined;
    flag.name = name;
    flag.next = this.firstFlag;
    this.firstFlag = flag;
  }

  run(source: Source, log: Log): void {
    var firstToken = source.firstToken;

    if (firstToken != null && firstToken.kind == TokenKind.PREPROCESSOR_NEEDED) {
      var firstFlag = this.firstFlag;

      // Initialize
      this.isDefineAndUndefAllowed = true;
      this.previous = firstToken;
      this.current = firstToken.next;
      this.log = log;

      // Don't parse this file if preprocessing failed
      if (!this.scan(true)) {
        source.firstToken = null;
        return;
      }

      // Make sure blocks are balanced
      if (!this.peek(TokenKind.END_OF_FILE)) {
        this.unexpectedToken();
      }

      // Restore the global-level state instead of letting the file-level state
      // leak over into the next file that the preprocessor is run on
      this.firstFlag = firstFlag;

      // Skip over the PREPROCESSOR_NEEDED token so the parser doesn't see it
      source.firstToken = source.firstToken.next;
    }
  }

  // Scan over the next reachable tokens, evaluate #define/#undef directives,
  // and fold #if/#else chains. Stop on #elif/#else/#endif. Return false on
  // failure. Takes a boolean flag for whether or not control flow is live in
  // this block.
  scan(isParentLive: bool): bool {
    while (!this.peek(TokenKind.END_OF_FILE) &&
        !this.peek(TokenKind.PREPROCESSOR_ELIF) &&
        !this.peek(TokenKind.PREPROCESSOR_ELSE) &&
        !this.peek(TokenKind.PREPROCESSOR_ENDIF)) {
      var previous = this.previous;
      var current = this.current;

      // #define or #undef
      if (this.eat(TokenKind.PREPROCESSOR_DEFINE) || this.eat(TokenKind.PREPROCESSOR_UNDEF)) {
        // Only process the directive if control flow is live at this point
        if (this.expect(TokenKind.IDENTIFIER) && isParentLive) {
          this.define(this.previous.range.toString(), current.kind == TokenKind.PREPROCESSOR_DEFINE);
        }

        // Help out people trying to use this like C
        if (this.peek(TokenKind.FALSE) || this.peek(TokenKind.INT) && string_equals(this.current.range.toString(), "0")) {
          this.advance();
          this.log.error(this.previous.range, "Use '#undef' to turn a preprocessor flag off");
        }

        // Scan up to the next newline
        if (!this.peek(TokenKind.END_OF_FILE) && !this.expect(TokenKind.PREPROCESSOR_NEWLINE)) {
          while (!this.eat(TokenKind.PREPROCESSOR_NEWLINE) && !this.eat(TokenKind.END_OF_FILE)) {
            this.advance();
          }
        }

        // These statements are only valid at the top of the file
        if (!this.isDefineAndUndefAllowed) {
          this.log.error(spanRanges(current.range, this.previous.range),
            "All '#define' and '#undef' directives must be at the top of the file");
        }

        // Remove all of these tokens
        this.removeTokensFrom(previous);
      }

      // #warning or #error
      else if (this.eat(TokenKind.PREPROCESSOR_WARNING) || this.eat(TokenKind.PREPROCESSOR_ERROR)) {
        var next = this.current;

        // Scan up to the next newline
        while (!this.peek(TokenKind.PREPROCESSOR_NEWLINE) && !this.peek(TokenKind.END_OF_FILE)) {
          this.advance();
        }

        // Only process the directive if control flow is live at this point
        if (isParentLive) {
          var range = this.current == next ? current.range : spanRanges(next.range, this.previous.range);
          this.log.append(range, range.toString(), current.kind == TokenKind.PREPROCESSOR_WARNING ? DiagnosticKind.WARNING : DiagnosticKind.ERROR);
        }

        // Remove all of these tokens
        this.eat(TokenKind.PREPROCESSOR_NEWLINE);
        this.removeTokensFrom(previous);
      }

      // #if
      else if (this.eat(TokenKind.PREPROCESSOR_IF)) {
        var isLive = isParentLive;

        // Scan over the entire if-else chain
        while (true) {
          var name = this.current;

          // Reject if the identifier is missing
          if (!this.expect(TokenKind.IDENTIFIER) || !this.expect(TokenKind.PREPROCESSOR_NEWLINE)) {
            return false;
          }

          // Remove the #if/#elif header
          this.removeTokensFrom(previous);

          // Evaluate the condition
          var condition = this.isDefined(name.range.toString());

          // Scan to the next #elif, #else, or #endif
          if (!this.scan(isLive && condition)) {
            return false;
          }

          // Remove these tokens?
          if (!isLive || !condition) {
            this.removeTokensFrom(previous);
          }

          // Keep these tokens but remove all subsequent branches
          else {
            isLive = false;
          }

          // Update the previous pointer so we remove from here next
          previous = this.previous;

          // #elif
          if (this.eat(TokenKind.PREPROCESSOR_ELIF)) {
            continue;
          }

          // #else
          if (this.eat(TokenKind.PREPROCESSOR_ELSE)) {
            if (!this.expect(TokenKind.PREPROCESSOR_NEWLINE)) {
              return false;
            }

            // Remove the #else
            this.removeTokensFrom(previous);

            // Scan to the #endif
            if (!this.scan(isLive)) {
              return false;
            }

            // Remove these tokens?
            if (!isLive) {
              this.removeTokensFrom(previous);
            }
          }

          // #endif
          break;
        }

        // All if-else chains end with an #endif
        previous = this.previous;
        if (!this.expect(TokenKind.PREPROCESSOR_ENDIF) || !this.peek(TokenKind.END_OF_FILE) && !this.expect(TokenKind.PREPROCESSOR_NEWLINE)) {
          return false;
        }
        this.removeTokensFrom(previous);
      }

      // Skip normal tokens
      else {
        this.isDefineAndUndefAllowed = false;
        this.advance();
      }
    }

    return true;
  }
}
