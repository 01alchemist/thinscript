extern function string_new(length: uint): string {
  unsafe {
    var ptr = malloc(4 + length);
    (ptr as UIntPtr).value = length;
    return ptr as string;
  }
}

function string_length(text: string): int {
  unsafe {
    return (text as UIntPtr).value as int;
  }
}

function string_get(text: string, index: int): int {
  assert(index as uint < string_length(text) as uint);
  unsafe {
    return ((text as int + index + 4) as UBytePtr).value;
  }
}

function string_equals(a: string, b: string): bool {
  unsafe {
    var length = (a as UIntPtr).value;

    // Check the length first
    if (length != (b as UIntPtr).value) {
      return false;
    }

    // Check the content next
    var ai = a as uint + 4;
    var bi = b as uint + 4;
    var an = ai + (length & ~3 as uint);

    // Compare 32-bit values for speed
    while (ai < an) {
      if ((ai as UIntPtr).value != (bi as UIntPtr).value) {
        return false;
      }
      ai = ai + 4;
      bi = bi + 4;
    }

    // Compare trailing 8-bit values
    an = ai + length % 4;
    while (ai < an) {
      if ((ai as UBytePtr).value != (bi as UBytePtr).value) {
        return false;
      }
      ai = ai + 1;
      bi = bi + 1;
    }

    return true;
  }
}

function string_slice(text: string, start: int, end: int): string {
  assert(start >= 0 && start <= end && end <= string_length(text));
  unsafe {
    var length = (end - start) as uint;
    var ptr = string_new(length);
    memcpy(ptr as uint + 4, text as uint + 4 + start as uint, length);
    return ptr;
  }
}

class StringBuilder {
  next: StringBuilder;
  _bytes: ByteArray;

  clear(): void {
    var bytes = this._bytes;
    if (bytes == null) {
      bytes = new ByteArray();
      this._bytes = bytes;
    } else {
      bytes.clear();
    }
  }

  appendChar(c: ubyte): StringBuilder {
    this._bytes.append(c);
    return this;
  }

  // TODO: Make this more efficient
  appendSlice(text: string, start: int, end: int): StringBuilder {
    return this.append(string_slice(text, start, end));
  }

  append(text: string): StringBuilder {
    var bytes = this._bytes;
    var index = bytes._length;
    unsafe {
      var length = (text as UIntPtr).value;
      bytes.resize((index + length) as int);
      memcpy(bytes._data + index, text as uint + 4, length);
    }
    return this;
  }

  // This also "frees" this object (puts it back in the pool)
  finish(): string {
    this.next = stringBuilderPool;
    stringBuilderPool = this;
    unsafe {
      var bytes = this._bytes;
      var length = bytes._length;
      var ptr = string_new(length);
      memcpy(ptr as uint + 4, bytes._data, length);
      return ptr;
    }
  }
}
