// Control flow operators
const WASM_OPCODE_NOP: ubyte = 0;
const WASM_OPCODE_BLOCK: ubyte = 1;
const WASM_OPCODE_LOOP: ubyte = 2;
const WASM_OPCODE_IF: ubyte = 3;
const WASM_OPCODE_IF_ELSE: ubyte = 4;
const WASM_OPCODE_SELECT: ubyte = 5;
const WASM_OPCODE_BR: ubyte = 6;
const WASM_OPCODE_BR_IF: ubyte = 7;
const WASM_OPCODE_BR_TABLE: ubyte = 8;
const WASM_OPCODE_RETURN: ubyte = 20;
const WASM_OPCODE_UNREACHABLE: ubyte = 21;

// Basic operators
const WASM_OPCODE_I32_CONST: ubyte = 10;
const WASM_OPCODE_I64_CONST: ubyte = 11;
const WASM_OPCODE_F64_CONST: ubyte = 12;
const WASM_OPCODE_F32_CONST: ubyte = 13;
const WASM_OPCODE_GET_LOCAL: ubyte = 14;
const WASM_OPCODE_SET_LOCAL: ubyte = 15;
const WASM_OPCODE_CALL: ubyte = 18;
const WASM_OPCODE_CALL_INDIRECT: ubyte = 19;
const WASM_OPCODE_CALL_IMPORT: ubyte = 31;

// Memory-related operators
const WASM_OPCODE_I32_LOAD8_S: ubyte = 32;
const WASM_OPCODE_I32_LOAD8_U: ubyte = 33;
const WASM_OPCODE_I32_LOAD16_S: ubyte = 34;
const WASM_OPCODE_I32_LOAD16_U: ubyte = 35;
const WASM_OPCODE_I64_LOAD8_S: ubyte = 36;
const WASM_OPCODE_I64_LOAD8_U: ubyte = 37;
const WASM_OPCODE_I64_LOAD16_S: ubyte = 38;
const WASM_OPCODE_I64_LOAD16_U: ubyte = 39;
const WASM_OPCODE_I64_LOAD32_S: ubyte = 40;
const WASM_OPCODE_I64_LOAD32_U: ubyte = 41;
const WASM_OPCODE_I32_LOAD: ubyte = 42;
const WASM_OPCODE_I64_LOAD: ubyte = 43;
const WASM_OPCODE_F32_LOAD: ubyte = 44;
const WASM_OPCODE_F64_LOAD: ubyte = 45;
const WASM_OPCODE_I32_STORE8: ubyte = 46;
const WASM_OPCODE_I32_STORE16: ubyte = 47;
const WASM_OPCODE_I64_STORE8: ubyte = 48;
const WASM_OPCODE_I64_STORE16: ubyte = 49;
const WASM_OPCODE_I64_STORE32: ubyte = 50;
const WASM_OPCODE_I32_STORE: ubyte = 51;
const WASM_OPCODE_I64_STORE: ubyte = 52;
const WASM_OPCODE_F32_STORE: ubyte = 53;
const WASM_OPCODE_F64_STORE: ubyte = 54;
const WASM_OPCODE_MEMORY_SIZE: ubyte = 59;
const WASM_OPCODE_GROW_MEMORY: ubyte = 57;

// Simple operators
const WASM_OPCODE_I32_ADD: ubyte = 64;
const WASM_OPCODE_I32_SUB: ubyte = 65;
const WASM_OPCODE_I32_MUL: ubyte = 66;
const WASM_OPCODE_I32_DIV_S: ubyte = 67;
const WASM_OPCODE_I32_DIV_U: ubyte = 68;
const WASM_OPCODE_I32_REM_S: ubyte = 69;
const WASM_OPCODE_I32_REM_U: ubyte = 70;
const WASM_OPCODE_I32_AND: ubyte = 71;
const WASM_OPCODE_I32_OR: ubyte = 72;
const WASM_OPCODE_I32_XOR: ubyte = 73;
const WASM_OPCODE_I32_SHL: ubyte = 74;
const WASM_OPCODE_I32_SHR_U: ubyte = 75;
const WASM_OPCODE_I32_SHR_S: ubyte = 76;
const WASM_OPCODE_I32_ROTR: ubyte = 182;
const WASM_OPCODE_I32_ROTL: ubyte = 183;
const WASM_OPCODE_I32_EQ: ubyte = 77;
const WASM_OPCODE_I32_NE: ubyte = 78;
const WASM_OPCODE_I32_LT_S: ubyte = 79;
const WASM_OPCODE_I32_LE_S: ubyte = 80;
const WASM_OPCODE_I32_LT_U: ubyte = 81;
const WASM_OPCODE_I32_LE_U: ubyte = 82;
const WASM_OPCODE_I32_GT_S: ubyte = 83;
const WASM_OPCODE_I32_GE_S: ubyte = 84;
const WASM_OPCODE_I32_GT_U: ubyte = 85;
const WASM_OPCODE_I32_GE_U: ubyte = 86;
const WASM_OPCODE_I32_CLZ: ubyte = 87;
const WASM_OPCODE_I32_CTZ: ubyte = 88;
const WASM_OPCODE_I32_POPCNT: ubyte = 89;
const WASM_OPCODE_I32_EQZ: ubyte = 90;
const WASM_OPCODE_I64_ADD: ubyte = 91;
const WASM_OPCODE_I64_SUB: ubyte = 92;
const WASM_OPCODE_I64_MUL: ubyte = 93;
const WASM_OPCODE_I64_DIV_S: ubyte = 94;
const WASM_OPCODE_I64_DIV_U: ubyte = 95;
const WASM_OPCODE_I64_REM_S: ubyte = 96;
const WASM_OPCODE_I64_REM_U: ubyte = 97;
const WASM_OPCODE_I64_AND: ubyte = 98;
const WASM_OPCODE_I64_OR: ubyte = 99;
const WASM_OPCODE_I64_XOR: ubyte = 100;
const WASM_OPCODE_I64_SHL: ubyte = 101;
const WASM_OPCODE_I64_SHR_U: ubyte = 102;
const WASM_OPCODE_I64_SHR_S: ubyte = 103;
const WASM_OPCODE_I64_ROTR: ubyte = 184;
const WASM_OPCODE_I64_ROTL: ubyte = 185;
const WASM_OPCODE_I64_EQ: ubyte = 104;
const WASM_OPCODE_I64_NE: ubyte = 105;
const WASM_OPCODE_I64_LT_S: ubyte = 106;
const WASM_OPCODE_I64_LE_S: ubyte = 107;
const WASM_OPCODE_I64_LT_U: ubyte = 108;
const WASM_OPCODE_I64_LE_U: ubyte = 109;
const WASM_OPCODE_I64_GT_S: ubyte = 110;
const WASM_OPCODE_I64_GE_S: ubyte = 111;
const WASM_OPCODE_I64_GT_U: ubyte = 112;
const WASM_OPCODE_I64_GE_U: ubyte = 113;
const WASM_OPCODE_I64_CLZ: ubyte = 114;
const WASM_OPCODE_I64_CTZ: ubyte = 115;
const WASM_OPCODE_I64_POPCNT: ubyte = 116;
const WASM_OPCODE_I64_EQZ: ubyte = 186;
const WASM_OPCODE_F32_ADD: ubyte = 117;
const WASM_OPCODE_F32_SUB: ubyte = 118;
const WASM_OPCODE_F32_MUL: ubyte = 119;
const WASM_OPCODE_F32_DIV: ubyte = 120;
const WASM_OPCODE_F32_MIN: ubyte = 121;
const WASM_OPCODE_F32_MAX: ubyte = 122;
const WASM_OPCODE_F32_ABS: ubyte = 123;
const WASM_OPCODE_F32_NEG: ubyte = 124;
const WASM_OPCODE_F32_COPYSIGN: ubyte = 125;
const WASM_OPCODE_F32_CEIL: ubyte = 126;
const WASM_OPCODE_F32_FLOOR: ubyte = 127;
const WASM_OPCODE_F32_TRUNC: ubyte = 128;
const WASM_OPCODE_F32_NEAREST: ubyte = 129;
const WASM_OPCODE_F32_SQRT: ubyte = 130;
const WASM_OPCODE_F32_EQ: ubyte = 131;
const WASM_OPCODE_F32_NE: ubyte = 132;
const WASM_OPCODE_F32_LT: ubyte = 133;
const WASM_OPCODE_F32_LE: ubyte = 134;
const WASM_OPCODE_F32_GT: ubyte = 135;
const WASM_OPCODE_F32_GE: ubyte = 136;
const WASM_OPCODE_F64_ADD: ubyte = 137;
const WASM_OPCODE_F64_SUB: ubyte = 138;
const WASM_OPCODE_F64_MUL: ubyte = 139;
const WASM_OPCODE_F64_DIV: ubyte = 140;
const WASM_OPCODE_F64_MIN: ubyte = 141;
const WASM_OPCODE_F64_MAX: ubyte = 142;
const WASM_OPCODE_F64_ABS: ubyte = 143;
const WASM_OPCODE_F64_NEG: ubyte = 144;
const WASM_OPCODE_F64_COPYSIGN: ubyte = 145;
const WASM_OPCODE_F64_CEIL: ubyte = 146;
const WASM_OPCODE_F64_FLOOR: ubyte = 147;
const WASM_OPCODE_F64_TRUNC: ubyte = 148;
const WASM_OPCODE_F64_NEAREST: ubyte = 149;
const WASM_OPCODE_F64_SQRT: ubyte = 150;
const WASM_OPCODE_F64_EQ: ubyte = 151;
const WASM_OPCODE_F64_NE: ubyte = 152;
const WASM_OPCODE_F64_LT: ubyte = 153;
const WASM_OPCODE_F64_LE: ubyte = 154;
const WASM_OPCODE_F64_GT: ubyte = 155;
const WASM_OPCODE_F64_GE: ubyte = 156;
const WASM_OPCODE_I32_TRUNC_S_F32: ubyte = 157;
const WASM_OPCODE_I32_TRUNC_S_F64: ubyte = 158;
const WASM_OPCODE_I32_TRUNC_U_F32: ubyte = 159;
const WASM_OPCODE_I32_TRUNC_U_F64: ubyte = 160;
const WASM_OPCODE_I32_WRAP_I64: ubyte = 161;
const WASM_OPCODE_I64_TRUNC_S_F32: ubyte = 162;
const WASM_OPCODE_I64_TRUNC_S_F64: ubyte = 163;
const WASM_OPCODE_I64_TRUNC_U_F32: ubyte = 164;
const WASM_OPCODE_I64_TRUNC_U_F64: ubyte = 165;
const WASM_OPCODE_I64_EXTEND_S_I32: ubyte = 166;
const WASM_OPCODE_I64_EXTEND_U_I32: ubyte = 167;
const WASM_OPCODE_F32_CONVERT_S_I32: ubyte = 168;
const WASM_OPCODE_F32_CONVERT_U_I32: ubyte = 169;
const WASM_OPCODE_F32_CONVERT_S_I64: ubyte = 170;
const WASM_OPCODE_F32_CONVERT_U_I64: ubyte = 171;
const WASM_OPCODE_F32_DEMOTE_F64: ubyte = 172;
const WASM_OPCODE_F32_REINTERPRET_I32: ubyte = 173;
const WASM_OPCODE_F64_CONVERT_S_I32: ubyte = 174;
const WASM_OPCODE_F64_CONVERT_U_I32: ubyte = 175;
const WASM_OPCODE_F64_CONVERT_S_I64: ubyte = 176;
const WASM_OPCODE_F64_CONVERT_U_I64: ubyte = 177;
const WASM_OPCODE_F64_PROMOTE_F32: ubyte = 178;
const WASM_OPCODE_F64_REINTERPRET_I64: ubyte = 179;
const WASM_OPCODE_I32_REINTERPRET_F32: ubyte = 180;
const WASM_OPCODE_I64_REINTERPRET_F64: ubyte = 181;

const WASM_MAGIC = 0x6D736100;
const WASM_VERSION = 10;
const WASM_SIZE_IN_PAGES = 256;
const WASM_MEMORY_INITIALIZER_BASE = 8; // Leave space for "null"

enum WasmType {
  VOID = 0,
  I32 = 1,
  I64 = 2,
  F32 = 3,
  F64 = 4,
}

class WasmWrappedType {
  id: WasmType;
  next: WasmWrappedType;
}

class WasmSignature {
  argumentTypes: WasmWrappedType;
  returnType: WasmWrappedType;
  next: WasmSignature;
}

function wasmAreSignaturesEqual(a: WasmSignature, b: WasmSignature): bool {
  assert(a.returnType != null);
  assert(b.returnType != null);
  assert(a.returnType.next == null);
  assert(b.returnType.next == null);

  var x = a.argumentTypes;
  var y = b.argumentTypes;

  while (x != null && y != null) {
    if (x.id != y.id) {
      return false;
    }

    x = x.next;
    y = y.next;
  }

  if (x != null || y != null) {
    return false;
  }

  if (a.returnType.id != b.returnType.id) {
    return false;
  }

  return true;
}

class WasmFunction {
  name: String;
  signatureIndex: int;
  body: Node;
  isExported: bool;
  intLocalCount: int;
  next: WasmFunction;
}

class WasmImport {
  signatureIndex: int;
  module: String;
  name: String;
  next: WasmImport;
}

class WasmModule {
  firstImport: WasmImport;
  lastImport: WasmImport;
  importCount: int;

  firstFunction: WasmFunction;
  lastFunction: WasmFunction;
  functionCount: int;

  firstSignature: WasmSignature;
  lastSignature: WasmSignature;
  signatureCount: int;

  memoryInitializer: ByteArray;
  heapPointerOffset: int;
  mallocFunctionIndex: int;
  context: CheckContext;

  growMemoryInitializer(): void {
    var array = this.memoryInitializer;
    var current = ByteArray_length(array);
    var length = this.context.nextGlobalVariableOffset;

    while (current < length) {
      ByteArray_appendByte(array, 0);
      current = current + 1;
    }
  }

  allocateImport(signatureIndex: int, mod: String, name: String): WasmImport {
    var result = new WasmImport();
    result.signatureIndex = signatureIndex;
    result.module = mod;
    result.name = name;

    if (this.firstImport == null) this.firstImport = result;
    else this.lastImport.next = result;
    this.lastImport = result;

    this.importCount = this.importCount + 1;
    return result;
  }

  allocateFunction(name: String, signatureIndex: int, body: Node): WasmFunction {
    var fn = new WasmFunction();
    fn.name = name;
    fn.signatureIndex = signatureIndex;
    fn.body = body;

    if (this.firstFunction == null) this.firstFunction = fn;
    else this.lastFunction.next = fn;
    this.lastFunction = fn;

    this.functionCount = this.functionCount + 1;
    return fn;
  }

  allocateSignature(argumentTypes: WasmWrappedType, returnType: WasmWrappedType): int {
    assert(returnType != null);
    assert(returnType.next == null);

    var signature = new WasmSignature();
    signature.argumentTypes = argumentTypes;
    signature.returnType = returnType;

    var check = this.firstSignature;
    var i = 0;

    while (check != null) {
      if (wasmAreSignaturesEqual(signature, check)) {
        return i;
      }

      check = check.next;
      i = i + 1;
    }

    if (this.firstSignature == null) this.firstSignature = signature;
    else this.lastSignature.next = signature;
    this.lastSignature = signature;

    this.signatureCount = this.signatureCount + 1;
    return i;
  }

  emitModule(array: ByteArray): void {
    ByteArray_appendByte(array, WASM_MAGIC as ubyte);
    ByteArray_appendByte(array, (WASM_MAGIC >> 8) as ubyte);
    ByteArray_appendByte(array, (WASM_MAGIC >> 16) as ubyte);
    ByteArray_appendByte(array, (WASM_MAGIC >> 24) as ubyte);

    ByteArray_appendByte(array, WASM_VERSION as ubyte);
    ByteArray_appendByte(array, (WASM_VERSION >> 8) as ubyte);
    ByteArray_appendByte(array, (WASM_VERSION >> 16) as ubyte);
    ByteArray_appendByte(array, (WASM_VERSION >> 24) as ubyte);

    this.emitSignatures(array);
    this.emitImportTable(array);
    this.emitFunctionSignatures(array);
    this.emitMemory(array);
    this.emitExportTable(array);
    this.emitFunctionBodies(array);
    this.emitDataSegments(array);
  }

  emitSignatures(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("signatures"));
    wasmWriteVarUnsigned(array, this.signatureCount);

    var signature = this.firstSignature;
    while (signature != null) {
      var count = 0;
      var type = signature.argumentTypes;

      while (type != null) {
        count = count + 1;
        type = type.next;
      }

      wasmWriteVarUnsigned(array, count);
      wasmWriteVarUnsigned(array, signature.returnType.id as int);

      type = signature.argumentTypes;
      while (type != null) {
        wasmWriteVarUnsigned(array, type.id as int);
        type = type.next;
      }

      signature = signature.next;
    }

    wasmFinishSection(array, section);
  }

  emitImportTable(array: ByteArray): void {
    if (this.firstImport == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("import_table"));
    wasmWriteVarUnsigned(array, this.importCount);

    var current = this.firstImport;
    while (current != null) {
      wasmWriteVarUnsigned(array, current.signatureIndex);
      wasmWriteLengthPrefixedString(array, current.module);
      wasmWriteLengthPrefixedString(array, current.name);
      current = current.next;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionSignatures(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_signatures"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      wasmWriteVarUnsigned(array, fn.signatureIndex);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitMemory(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("memory"));
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, 1); // The memory array is exported
    wasmFinishSection(array, section);
  }

  emitExportTable(array: ByteArray): void {
    var exportedCount = 0;
    var fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        exportedCount = exportedCount + 1;
      }
      fn = fn.next;
    }
    if (exportedCount == 0) {
      return;
    }

    var section = wasmStartSection(array, String_new("export_table"));
    wasmWriteVarUnsigned(array, exportedCount);

    var i = 0;
    fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        wasmWriteVarUnsigned(array, i);
        wasmWriteLengthPrefixedString(array, fn.name);
      }
      fn = fn.next;
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionBodies(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_bodies"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      var bodyLength = ByteArray_length(array);
      wasmWriteVarUnsigned(array, ~0); // This will be patched later

      if (fn.intLocalCount > 0) {
        wasmWriteVarUnsigned(array, 1);
        wasmWriteVarUnsigned(array, fn.intLocalCount);
        ByteArray_appendByte(array, WasmType.I32);
      } else {
        wasmWriteVarUnsigned(array, 0);
      }

      var child = fn.body.firstChild;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }

      wasmPatchVarUnsigned(array, bodyLength, ByteArray_length(array) - bodyLength - 5, ~0);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitDataSegments(array: ByteArray): void {
    this.growMemoryInitializer();
    var memoryInitializer = this.memoryInitializer;
    var initalizerLength = ByteArray_length(memoryInitializer);
    var initialHeapPointer = alignToNextMultipleOf(WASM_MEMORY_INITIALIZER_BASE + initalizerLength, 8);

    // Pass the initial heap pointer to "malloc"
    var heapPointerOffset = this.heapPointerOffset;
    ByteArray_setByte(memoryInitializer, heapPointerOffset, initialHeapPointer as ubyte);
    ByteArray_setByte(memoryInitializer, heapPointerOffset + 1, (initialHeapPointer >> 8) as ubyte);
    ByteArray_setByte(memoryInitializer, heapPointerOffset + 2, (initialHeapPointer >> 16) as ubyte);
    ByteArray_setByte(memoryInitializer, heapPointerOffset + 3, (initialHeapPointer >> 24) as ubyte);

    var section = wasmStartSection(array, String_new("data_segments"));
    wasmWriteVarUnsigned(array, 1);

    wasmWriteVarUnsigned(array, WASM_MEMORY_INITIALIZER_BASE);
    wasmWriteVarUnsigned(array, initalizerLength);

    // Copy the entire memory initializer (also includes zero-initialized data for now)
    var i = 0;
    while (i < initalizerLength) {
      ByteArray_appendByte(array, ByteArray_getByte(memoryInitializer, i));
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  prepareToEmit(node: Node): void {
    if (node.kind == NodeKind.STRING) {
      var text = node.stringValue;
      var length = String_length(text);
      var offset = this.context.allocateGlobalVariableOffset(length + 1, 1);;
      this.growMemoryInitializer();
      var memoryInitializer = this.memoryInitializer;
      var i = 0;
      while (i < length) {
        ByteArray_setByte(memoryInitializer, offset + i, String_get(text, i) as ubyte);
        i = i + 1;
      }
      ByteArray_setByte(memoryInitializer, offset + length, 0);
      node.intValue = offset;
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var symbol = node.symbol;

      // Make sure the heap offset is tracked
      if (node.symbol.kind == SymbolKind.VARIABLE_GLOBAL && String_equalNew(symbol.name, "__mallocOffset")) {
        assert(this.heapPointerOffset == -1);
        this.heapPointerOffset = symbol.offset;
      }
    }

    else if (node.kind == NodeKind.FUNCTION) {
      var returnType = node.functionReturnType();
      var shared = new WasmSharedOffset();
      var argumentTypesFirst: WasmWrappedType = null;
      var argumentTypesLast: WasmWrappedType = null;

      // Make sure to include the implicit "this" variable as a normal argument
      var argument = node.firstChild;
      while (argument != returnType) {
        var type = wasmWrapType(this.getWasmType(argument.variableType().resolvedType));

        if (argumentTypesFirst == null) argumentTypesFirst = type;
        else argumentTypesLast.next = type;
        argumentTypesLast = type;

        shared.nextLocalOffset = shared.nextLocalOffset + 1;
        argument = argument.nextSibling;
      }
      var signatureIndex = this.allocateSignature(argumentTypesFirst, wasmWrapType(this.getWasmType(returnType.resolvedType)));
      var body = node.functionBody();
      var symbol = node.symbol;

      // Functions without bodies are imports
      if (body == null) {
        symbol.offset = this.importCount;
        this.allocateImport(signatureIndex, String_new("imports"), symbol.name);
        node = node.nextSibling;
        return;
      }

      symbol.offset = this.functionCount;
      var fn = this.allocateFunction(symbol.name, signatureIndex, body);

      // Make sure "malloc" is tracked
      if (symbol.kind == SymbolKind.FUNCTION_GLOBAL && String_equalNew(symbol.name, "__malloc")) {
        assert(this.mallocFunctionIndex == -1);
        this.mallocFunctionIndex = symbol.offset;
      }

      // Only export "extern" functions
      if (symbol.isExtern()) {
        fn.isExported = true;
      }

      // Assign local variable offsets
      wasmAssignLocalVariableOffsets(body, shared);
      fn.intLocalCount = shared.intLocalCount;
    }

    var child = node.firstChild;
    while (child != null) {
      this.prepareToEmit(child);
      child = child.nextSibling;
    }
  }

  emitBinaryExpression(array: ByteArray, node: Node, opcode: ubyte): void {
    ByteArray_appendByte(array, opcode);
    this.emitNode(array, node.binaryLeft());
    this.emitNode(array, node.binaryRight());
  }

  emitLoadFromMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int): void {
    var sizeOf = type.sizeOf();

    if (sizeOf == 1) {
      ByteArray_appendByte(array, type.isUnsigned() ? WASM_OPCODE_I32_LOAD8_U : WASM_OPCODE_I32_LOAD8_S);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      ByteArray_appendByte(array, type.isUnsigned() ? WASM_OPCODE_I32_LOAD16_U : WASM_OPCODE_I32_LOAD16_S);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      ByteArray_appendByte(array, WASM_OPCODE_I32_LOAD);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      ByteArray_appendByte(array, WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }
  }

  emitStoreToMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int, value: Node): void {
    var sizeOf = type.sizeOf();

    if (sizeOf == 1) {
      ByteArray_appendByte(array, WASM_OPCODE_I32_STORE8);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      ByteArray_appendByte(array, WASM_OPCODE_I32_STORE16);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      ByteArray_appendByte(array, WASM_OPCODE_I32_STORE);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      ByteArray_appendByte(array, WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }

    this.emitNode(array, value);
  }

  emitNode(array: ByteArray, node: Node): int {
    assert(!isExpression(node) || node.resolvedType != null);

    if (node.kind == NodeKind.BLOCK) {
      ByteArray_appendByte(array, WASM_OPCODE_BLOCK);
      var offset = ByteArray_length(array);
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.WHILE) {
      var value = node.whileValue();
      var body = node.whileBody();

      // Ignore "while (false) { ... }"
      if (value.kind == NodeKind.BOOL && value.intValue == 0) {
        return 0;
      }

      ByteArray_appendByte(array, WASM_OPCODE_LOOP);
      var offset = ByteArray_length(array);
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;

      // Emit the condition as "loop { if (!condition) break; }" as long as it's not a "while (true)" loop
      if (value.kind != NodeKind.BOOL) {
        ByteArray_appendByte(array, WASM_OPCODE_BR_IF);
        wasmWriteVarUnsigned(array, 1); // Break out of the immediately enclosing loop
        ByteArray_appendByte(array, WASM_OPCODE_NOP); // This is a statement, not an expression
        ByteArray_appendByte(array, WASM_OPCODE_I32_EQZ); // The conditional is flipped
        this.emitNode(array, value);
        count = count + 1;
      }

      var child = body.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }

      // Jump back to the top (this doesn't happen automatically)
      ByteArray_appendByte(array, WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, 0); // Continue back to the immediately enclosing loop
      ByteArray_appendByte(array, WASM_OPCODE_NOP); // This is a statement, not an expression
      count = count + 1;

      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.BREAK || node.kind == NodeKind.CONTINUE) {
      var label = 0;
      var parent = node.parent;

      while (parent != null && parent.kind != NodeKind.WHILE) {
        if (parent.kind == NodeKind.BLOCK) {
          label = label + 1;
        }
        parent = parent.parent;
      }

      assert(label > 0);
      ByteArray_appendByte(array, WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, label - (node.kind == NodeKind.BREAK ? 0 : 1));
      ByteArray_appendByte(array, WASM_OPCODE_NOP); // This is a statement, not an expression
    }

    else if (node.kind == NodeKind.EMPTY) {
      return 0;
    }

    else if (node.kind == NodeKind.EXPRESSION) {
      this.emitNode(array, node.expressionValue());
    }

    else if (node.kind == NodeKind.RETURN) {
      var value = node.returnValue();
      ByteArray_appendByte(array, WASM_OPCODE_RETURN);
      if (value != null) {
        this.emitNode(array, value);
      }
    }

    else if (node.kind == NodeKind.VARIABLES) {
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        assert(child.kind == NodeKind.VARIABLE);
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      return count;
    }

    else if (node.kind == NodeKind.IF) {
      var branch = node.ifFalse();
      ByteArray_appendByte(array, branch == null ? WASM_OPCODE_IF : WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.ifValue());
      this.emitNode(array, node.ifTrue());
      if (branch != null) {
        this.emitNode(array, branch);
      }
    }

    else if (node.kind == NodeKind.HOOK) {
      ByteArray_appendByte(array, WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.hookValue());
      this.emitNode(array, node.hookTrue());
      this.emitNode(array, node.hookFalse());
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var value = node.variableValue();

      if (node.symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        ByteArray_appendByte(array, WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, node.symbol.offset);

        if (value != null) {
          this.emitNode(array, value);
        }

        // Default initialization
        else {
          ByteArray_appendByte(array, WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, 0);
        }
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NAME) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        ByteArray_appendByte(array, WASM_OPCODE_GET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitLoadFromMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NULL) {
      ByteArray_appendByte(array, WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.INT || node.kind == NodeKind.BOOL) {
      ByteArray_appendByte(array, WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, node.intValue);
    }

    else if (node.kind == NodeKind.STRING) {
      ByteArray_appendByte(array, WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, WASM_MEMORY_INITIALIZER_BASE + node.intValue);
    }

    else if (node.kind == NodeKind.CALL) {
      var value = node.callValue();
      var symbol = value.symbol;
      assert(isFunction(symbol.kind));

      ByteArray_appendByte(array, symbol.node.functionBody() == null ? WASM_OPCODE_CALL_IMPORT : WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, symbol.offset);

      // Write out the implicit "this" argument
      if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
        this.emitNode(array, value.dotTarget());
      }

      var child = value.nextSibling;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }
    }

    else if (node.kind == NodeKind.NEW) {
      var type = node.newType();
      assert(type.symbol.kind == SymbolKind.TYPE_CLASS);

      ByteArray_appendByte(array, WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, this.mallocFunctionIndex);

      // Pass the object size as the first argument
      assert(type.symbol.byteSize > 0);
      ByteArray_appendByte(array, WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, type.symbol.byteSize);
    }

    else if (node.kind == NodeKind.POSITIVE) {
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NEGATIVE) {
      ByteArray_appendByte(array, WASM_OPCODE_I32_SUB);
      ByteArray_appendByte(array, WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.COMPLEMENT) {
      ByteArray_appendByte(array, WASM_OPCODE_I32_XOR);
      ByteArray_appendByte(array, WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, ~0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NOT) {
      ByteArray_appendByte(array, WASM_OPCODE_I32_EQZ);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.CAST) {
      var value = node.castValue();
      var context = this.context;
      var from = value.resolvedType.underlyingType(context);
      var type = node.resolvedType.underlyingType(context);

      // The cast isn't needed if it's to a wider integer type
      if (from == type || from.symbol.byteSize < type.symbol.byteSize) {
        this.emitNode(array, value);
      }

      else {
        // Sign-extend
        if (type == context.byteType || type == context.shortType) {
          var shift = 32 - type.symbol.byteSize * 8;
          ByteArray_appendByte(array, WASM_OPCODE_I32_SHR_S);
          ByteArray_appendByte(array, WASM_OPCODE_I32_SHL);
          this.emitNode(array, value);
          ByteArray_appendByte(array, WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
          ByteArray_appendByte(array, WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
        }

        // Mask
        else if (type == context.ubyteType || type == context.ushortType) {
          ByteArray_appendByte(array, WASM_OPCODE_I32_AND);
          this.emitNode(array, value);
          ByteArray_appendByte(array, WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, type.integerBitMask() as int);
        }

        // No cast needed
        else {
          this.emitNode(array, value);
        }
      }
    }

    else if (node.kind == NodeKind.DOT) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitLoadFromMemory(array, symbol.resolvedType, node.dotTarget(), symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.ASSIGN) {
      var left = node.binaryLeft();
      var symbol = left.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitStoreToMemory(array, symbol.resolvedType, left.dotTarget(), symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitStoreToMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        ByteArray_appendByte(array, WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
        this.emitNode(array, node.binaryRight());
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.LOGICAL_AND) {
      ByteArray_appendByte(array, WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      this.emitNode(array, node.binaryRight());
      ByteArray_appendByte(array, WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.LOGICAL_OR) {
      ByteArray_appendByte(array, WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      ByteArray_appendByte(array, WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 1);
      this.emitNode(array, node.binaryRight());
    }

    else {
      var isUnsigned = node.isUnsignedOperator();

      if (node.kind == NodeKind.ADD) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_ADD);
      else if (node.kind == NodeKind.BITWISE_AND) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_AND);
      else if (node.kind == NodeKind.BITWISE_OR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_OR);
      else if (node.kind == NodeKind.BITWISE_XOR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_XOR);
      else if (node.kind == NodeKind.EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_EQ);
      else if (node.kind == NodeKind.MULTIPLY) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_MUL);
      else if (node.kind == NodeKind.NOT_EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_NE);
      else if (node.kind == NodeKind.SHIFT_LEFT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SHL);
      else if (node.kind == NodeKind.SUBTRACT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SUB);

      else if (node.kind == NodeKind.DIVIDE) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_DIV_U : WASM_OPCODE_I32_DIV_S);
      else if (node.kind == NodeKind.GREATER_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GT_U : WASM_OPCODE_I32_GT_S);
      else if (node.kind == NodeKind.GREATER_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GE_U : WASM_OPCODE_I32_GE_S);
      else if (node.kind == NodeKind.LESS_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LT_U : WASM_OPCODE_I32_LT_S);
      else if (node.kind == NodeKind.LESS_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LE_U : WASM_OPCODE_I32_LE_S);
      else if (node.kind == NodeKind.REMAINDER) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_REM_U : WASM_OPCODE_I32_REM_S);
      else if (node.kind == NodeKind.SHIFT_RIGHT) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_SHR_U : WASM_OPCODE_I32_SHR_S);

      else {
        assert(false);
      }
    }

    return 1;
  }

  getWasmType(type: Type): WasmType {
    var context = this.context;

    if (type == context.boolType || type.isInteger() || type.isReference(context)) {
      return WasmType.I32;
    }

    if (type == context.voidType) {
      return WasmType.VOID;
    }

    assert(false);
    return WasmType.VOID;
  }
}

function wasmPatchVarUnsigned(array: ByteArray, offset: int, value: int, maxValue: int): void {
  var current = value as uint;
  var max = maxValue as uint;
  while (true) {
    var byte = current & 127;
    current = current >> 7;
    max = max >> 7;
    if (max != 0) {
      byte = byte | 128;
    }
    ByteArray_setByte(array, offset, byte as ubyte);
    offset = offset + 1;
    if (max == 0) {
      break;
    }
  }
}

function wasmWriteVarUnsigned(array: ByteArray, value: int): void {
  var current = value as uint;
  while (true) {
    var byte = current & 127;
    current = current >> 7;
    if (current != 0) {
      byte = byte | 128;
    }
    ByteArray_appendByte(array, byte as ubyte);
    if (current == 0) {
      break;
    }
  }
}

function wasmWriteVarSigned(array: ByteArray, value: int): void {
  while (true) {
    var byte = value & 127;
    value = value >> 7;
    var done =
      value == 0 && (byte & 64) == 0 ||
      value == -1 && (byte & 64) != 0;
    if (!done) {
      byte = byte | 128;
    }
    ByteArray_appendByte(array, byte as ubyte);
    if (done) {
      break;
    }
  }
}

function wasmWriteLengthPrefixedString(array: ByteArray, value: String): void {
  var length = String_length(value);
  wasmWriteVarUnsigned(array, length);
  var i = 0;
  while (i < length) {
    ByteArray_appendByte(array, String_get(value, i) as ubyte);
    i = i + 1;
  }
}

function wasmStartSection(array: ByteArray, name: String): int {
  var offset = ByteArray_length(array);
  wasmWriteVarUnsigned(array, ~0); // Section length, will be filled in later
  wasmWriteLengthPrefixedString(array, name);
  return offset;
}

function wasmFinishSection(array: ByteArray, offset: int): void {
  wasmPatchVarUnsigned(array, offset, ByteArray_length(array) - offset - 5, ~0);
}

function wasmWrapType(id: WasmType): WasmWrappedType {
  assert(id == WasmType.VOID || id == WasmType.I32);
  var type = new WasmWrappedType();
  type.id = id;
  return type;
}

class WasmSharedOffset {
  nextLocalOffset: int;
  intLocalCount: int;
}

function wasmAssignLocalVariableOffsets(node: Node, shared: WasmSharedOffset): void {
  if (node.kind == NodeKind.VARIABLE) {
    assert(node.symbol.kind == SymbolKind.VARIABLE_LOCAL);
    node.symbol.offset = shared.nextLocalOffset;
    shared.nextLocalOffset = shared.nextLocalOffset + 1;
    shared.intLocalCount = shared.intLocalCount + 1;
  }

  var child = node.firstChild;
  while (child != null) {
    wasmAssignLocalVariableOffsets(child, shared);
    child = child.nextSibling;
  }
}

function wasmEmit(global: Node, context: CheckContext, array: ByteArray): void {
  var module = new WasmModule();
  module.context = context;
  module.memoryInitializer = ByteArray_new();

  // Set these to invalid values since "0" is valid
  module.mallocFunctionIndex = -1;
  module.heapPointerOffset = -1;

  // Emission requires two passes
  module.prepareToEmit(global);

  // The standard library must be included
  assert(module.mallocFunctionIndex != -1);
  assert(module.heapPointerOffset != -1);

  module.emitModule(array);
}
