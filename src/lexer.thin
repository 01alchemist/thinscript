enum TokenKind {
  END_OF_FILE,

  // Literals
  CHARACTER,
  IDENTIFIER,
  INT,
  STRING,

  // Punctuation
  ASSIGN,
  BITWISE_AND,
  BITWISE_OR,
  BITWISE_XOR,
  COLON,
  COMMA,
  COMPLEMENT,
  DIVIDE,
  DOT,
  EQUAL,
  GREATER_THAN,
  GREATER_THAN_EQUAL,
  LEFT_BRACE,
  LEFT_BRACKET,
  LEFT_PARENTHESIS,
  LESS_THAN,
  LESS_THAN_EQUAL,
  LOGICAL_AND,
  LOGICAL_OR,
  MINUS,
  MINUS_MINUS,
  MULTIPLY,
  NOT,
  NOT_EQUAL,
  PLUS,
  PLUS_PLUS,
  QUESTION_MARK,
  REMAINDER,
  RIGHT_BRACE,
  RIGHT_BRACKET,
  RIGHT_PARENTHESIS,
  SEMICOLON,
  SHIFT_LEFT,
  SHIFT_RIGHT,

  // Keywords
  BREAK,
  CLASS,
  CONST,
  CONTINUE,
  ELSE,
  ENUM,
  EXPORT,
  EXTENDS,
  EXTERN,
  FALSE,
  FUNCTION,
  IF,
  IMPLEMENTS,
  IMPORT,
  INTERFACE,
  NEW,
  NULL,
  RETURN,
  THIS,
  TRUE,
  VAR,
  WHILE,
}

class Token {
  kind: TokenKind;
  range: Range;
  next: Token;
}

function tokenToString(token: TokenKind): string {
  if (token == TokenKind.ASSIGN) return "ASSIGN";
  if (token == TokenKind.BITWISE_AND) return "BITWISE_AND";
  if (token == TokenKind.BITWISE_OR) return "BITWISE_OR";
  if (token == TokenKind.BITWISE_XOR) return "BITWISE_XOR";
  if (token == TokenKind.BREAK) return "BREAK";
  if (token == TokenKind.CHARACTER) return "CHARACTER";
  if (token == TokenKind.CLASS) return "CLASS";
  if (token == TokenKind.COLON) return "COLON";
  if (token == TokenKind.COMMA) return "COMMA";
  if (token == TokenKind.COMPLEMENT) return "COMPLEMENT";
  if (token == TokenKind.CONST) return "CONST";
  if (token == TokenKind.CONTINUE) return "CONTINUE";
  if (token == TokenKind.DIVIDE) return "DIVIDE";
  if (token == TokenKind.DOT) return "DOT";
  if (token == TokenKind.ELSE) return "ELSE";
  if (token == TokenKind.END_OF_FILE) return "END_OF_FILE";
  if (token == TokenKind.ENUM) return "ENUM";
  if (token == TokenKind.EQUAL) return "EQUAL";
  if (token == TokenKind.EXPORT) return "EXPORT";
  if (token == TokenKind.EXTENDS) return "EXTENDS";
  if (token == TokenKind.EXTERN) return "EXTERN";
  if (token == TokenKind.FALSE) return "FALSE";
  if (token == TokenKind.FUNCTION) return "FUNCTION";
  if (token == TokenKind.GREATER_THAN) return "GREATER_THAN";
  if (token == TokenKind.GREATER_THAN_EQUAL) return "GREATER_THAN_EQUAL";
  if (token == TokenKind.IDENTIFIER) return "IDENTIFIER";
  if (token == TokenKind.IF) return "IF";
  if (token == TokenKind.IMPLEMENTS) return "IMPLEMENTS";
  if (token == TokenKind.IMPORT) return "IMPORT";
  if (token == TokenKind.INT) return "INT";
  if (token == TokenKind.INTERFACE) return "INTERFACE";
  if (token == TokenKind.LEFT_BRACE) return "LEFT_BRACE";
  if (token == TokenKind.LEFT_BRACKET) return "LEFT_BRACKET";
  if (token == TokenKind.LEFT_PARENTHESIS) return "LEFT_PARENTHESIS";
  if (token == TokenKind.LESS_THAN) return "LESS_THAN";
  if (token == TokenKind.LESS_THAN_EQUAL) return "LESS_THAN_EQUAL";
  if (token == TokenKind.LOGICAL_AND) return "LOGICAL_AND";
  if (token == TokenKind.LOGICAL_OR) return "LOGICAL_OR";
  if (token == TokenKind.MINUS) return "MINUS";
  if (token == TokenKind.MINUS_MINUS) return "MINUS_MINUS";
  if (token == TokenKind.MULTIPLY) return "MULTIPLY";
  if (token == TokenKind.NEW) return "NEW";
  if (token == TokenKind.NOT) return "NOT";
  if (token == TokenKind.NOT_EQUAL) return "NOT_EQUAL";
  if (token == TokenKind.NULL) return "NULL";
  if (token == TokenKind.PLUS) return "PLUS";
  if (token == TokenKind.PLUS_PLUS) return "PLUS_PLUS";
  if (token == TokenKind.QUESTION_MARK) return "QUESTION_MARK";
  if (token == TokenKind.REMAINDER) return "REMAINDER";
  if (token == TokenKind.RETURN) return "RETURN";
  if (token == TokenKind.RIGHT_BRACE) return "RIGHT_BRACE";
  if (token == TokenKind.RIGHT_BRACKET) return "RIGHT_BRACKET";
  if (token == TokenKind.RIGHT_PARENTHESIS) return "RIGHT_PARENTHESIS";
  if (token == TokenKind.SEMICOLON) return "SEMICOLON";
  if (token == TokenKind.SHIFT_LEFT) return "SHIFT_LEFT";
  if (token == TokenKind.SHIFT_RIGHT) return "SHIFT_RIGHT";
  if (token == TokenKind.STRING) return "STRING";
  if (token == TokenKind.THIS) return "THIS";
  if (token == TokenKind.TRUE) return "TRUE";
  if (token == TokenKind.VAR) return "VAR";
  if (token == TokenKind.WHILE) return "WHILE";
  return null;
}

function isAlpha(c: int): bool {
  return
    c >= 'a' && c <= 'z' ||
    c >= 'A' && c <= 'Z' ||
    c == '_';
}

function isNumber(c: int): bool {
  return c >= '0' && c <= '9';
}

function tokenize(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = String_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = String_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var text = String_slice(contents, start, i);
      if (String_equalNew(text, "break")) kind = TokenKind.BREAK;
      else if (String_equalNew(text, "class")) kind = TokenKind.CLASS;
      else if (String_equalNew(text, "const")) kind = TokenKind.CONST;
      else if (String_equalNew(text, "continue")) kind = TokenKind.CONTINUE;
      else if (String_equalNew(text, "else")) kind = TokenKind.ELSE;
      else if (String_equalNew(text, "enum")) kind = TokenKind.ENUM;
      else if (String_equalNew(text, "export")) kind = TokenKind.EXPORT;
      else if (String_equalNew(text, "extends")) kind = TokenKind.EXTENDS;
      else if (String_equalNew(text, "extern")) kind = TokenKind.EXTERN;
      else if (String_equalNew(text, "false")) kind = TokenKind.FALSE;
      else if (String_equalNew(text, "function")) kind = TokenKind.FUNCTION;
      else if (String_equalNew(text, "if")) kind = TokenKind.IF;
      else if (String_equalNew(text, "implements")) kind = TokenKind.IMPLEMENTS;
      else if (String_equalNew(text, "import")) kind = TokenKind.IMPORT;
      else if (String_equalNew(text, "interface")) kind = TokenKind.INTERFACE;
      else if (String_equalNew(text, "new")) kind = TokenKind.NEW;
      else if (String_equalNew(text, "null")) kind = TokenKind.NULL;
      else if (String_equalNew(text, "return")) kind = TokenKind.RETURN;
      else if (String_equalNew(text, "this")) kind = TokenKind.THIS;
      else if (String_equalNew(text, "true")) kind = TokenKind.TRUE;
      else if (String_equalNew(text, "var")) kind = TokenKind.VAR;
      else if (String_equalNew(text, "while")) kind = TokenKind.WHILE;
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      while (i < limit && isNumber(String_get(contents, i))) {
        i = i + 1;
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = String_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && String_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && String_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && String_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = String_get(contents, i);

          if (next == '*' && i + 1 < limit && String_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && String_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && String_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && String_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && String_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range,
        String_appendNew(
          String_append(
            String_new("Syntax error: '"),
            String_slice(contents, start, start + 1)),
          "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}
