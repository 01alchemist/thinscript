enum TokenKind {
  END_OF_FILE,

  // Literals
  CHARACTER,
  IDENTIFIER,
  INT,
  STRING,

  // Punctuation
  ASSIGN,
  BITWISE_AND,
  BITWISE_OR,
  BITWISE_XOR,
  COLON,
  COMMA,
  COMPLEMENT,
  DIVIDE,
  DOT,
  EQUAL,
  GREATER_THAN,
  GREATER_THAN_EQUAL,
  LEFT_BRACE,
  LEFT_BRACKET,
  LEFT_PARENTHESIS,
  LESS_THAN,
  LESS_THAN_EQUAL,
  LOGICAL_AND,
  LOGICAL_OR,
  MINUS,
  MINUS_MINUS,
  MULTIPLY,
  NOT,
  NOT_EQUAL,
  PLUS,
  PLUS_PLUS,
  QUESTION_MARK,
  REMAINDER,
  RIGHT_BRACE,
  RIGHT_BRACKET,
  RIGHT_PARENTHESIS,
  SEMICOLON,
  SHIFT_LEFT,
  SHIFT_RIGHT,

  // Keywords
  ALIGNOF,
  AS,
  BREAK,
  CLASS,
  CONST,
  CONTINUE,
  DECLARE,
  ELSE,
  ENUM,
  EXPORT,
  EXTENDS,
  EXTERN,
  FALSE,
  FUNCTION,
  IF,
  IMPLEMENTS,
  IMPORT,
  INTERFACE,
  LET,
  NEW,
  NULL,
  OPERATOR,
  PRIVATE,
  PROTECTED,
  PUBLIC,
  RETURN,
  SIZEOF,
  STATIC,
  THIS,
  TRUE,
  UNSAFE,
  VAR,
  WHILE,
}

function isKeyword(kind: TokenKind): bool {
  return kind >= TokenKind.ALIGNOF && kind <= TokenKind.WHILE;
}

class Token {
  kind: TokenKind;
  range: Range;
  next: Token;
}

function tokenToString(token: TokenKind): string {
  if (token == TokenKind.END_OF_FILE) return "end of file";

  // Literals
  if (token == TokenKind.CHARACTER) return "character literal";
  if (token == TokenKind.IDENTIFIER) return "identifier";
  if (token == TokenKind.INT) return "integer literal";
  if (token == TokenKind.STRING) return "string literal";

  // Punctuation
  if (token == TokenKind.ASSIGN) return "'='";
  if (token == TokenKind.BITWISE_AND) return "'&'";
  if (token == TokenKind.BITWISE_OR) return "'|'";
  if (token == TokenKind.BITWISE_XOR) return "'^'";
  if (token == TokenKind.COLON) return "':'";
  if (token == TokenKind.COMMA) return "','";
  if (token == TokenKind.COMPLEMENT) return "'~'";
  if (token == TokenKind.DIVIDE) return "'/'";
  if (token == TokenKind.DOT) return "'.'";
  if (token == TokenKind.EQUAL) return "'=='";
  if (token == TokenKind.GREATER_THAN) return "'>'";
  if (token == TokenKind.GREATER_THAN_EQUAL) return "'>='";
  if (token == TokenKind.LEFT_BRACE) return "'{'";
  if (token == TokenKind.LEFT_BRACKET) return "'['";
  if (token == TokenKind.LEFT_PARENTHESIS) return "'('";
  if (token == TokenKind.LESS_THAN) return "'<'";
  if (token == TokenKind.LESS_THAN_EQUAL) return "'<='";
  if (token == TokenKind.LOGICAL_AND) return "'&&'";
  if (token == TokenKind.LOGICAL_OR) return "'||'";
  if (token == TokenKind.MINUS) return "'-'";
  if (token == TokenKind.MINUS_MINUS) return "'--'";
  if (token == TokenKind.MULTIPLY) return "'*'";
  if (token == TokenKind.NOT) return "'!'";
  if (token == TokenKind.NOT_EQUAL) return "'!='";
  if (token == TokenKind.PLUS) return "'+'";
  if (token == TokenKind.PLUS_PLUS) return "'++'";
  if (token == TokenKind.QUESTION_MARK) return "'?'";
  if (token == TokenKind.REMAINDER) return "'%'";
  if (token == TokenKind.RIGHT_BRACE) return "'}'";
  if (token == TokenKind.RIGHT_BRACKET) return "']'";
  if (token == TokenKind.RIGHT_PARENTHESIS) return "')'";
  if (token == TokenKind.SEMICOLON) return "';'";
  if (token == TokenKind.SHIFT_LEFT) return "'<<'";
  if (token == TokenKind.SHIFT_RIGHT) return "'>>'";

  // Keywords
  if (token == TokenKind.ALIGNOF) return "'alignof'";
  if (token == TokenKind.AS) return "'as'";
  if (token == TokenKind.BREAK) return "'break'";
  if (token == TokenKind.CLASS) return "'class'";
  if (token == TokenKind.CONST) return "'const'";
  if (token == TokenKind.CONTINUE) return "'continue'";
  if (token == TokenKind.DECLARE) return "'declare'";
  if (token == TokenKind.ELSE) return "'else'";
  if (token == TokenKind.ENUM) return "'enum'";
  if (token == TokenKind.EXPORT) return "'export'";
  if (token == TokenKind.EXTENDS) return "'extends'";
  if (token == TokenKind.EXTERN) return "'extern'";
  if (token == TokenKind.FALSE) return "'false'";
  if (token == TokenKind.FUNCTION) return "'function'";
  if (token == TokenKind.IF) return "'if'";
  if (token == TokenKind.IMPLEMENTS) return "'implements'";
  if (token == TokenKind.IMPORT) return "'import'";
  if (token == TokenKind.INTERFACE) return "'interface'";
  if (token == TokenKind.LET) return "'let'";
  if (token == TokenKind.NEW) return "'new'";
  if (token == TokenKind.NULL) return "'null'";
  if (token == TokenKind.OPERATOR) return "'operator'";
  if (token == TokenKind.PRIVATE) return "'private'";
  if (token == TokenKind.PROTECTED) return "'protected'";
  if (token == TokenKind.PUBLIC) return "'public'";
  if (token == TokenKind.RETURN) return "'return'";
  if (token == TokenKind.SIZEOF) return "'sizeof'";
  if (token == TokenKind.STATIC) return "'static'";
  if (token == TokenKind.THIS) return "'this'";
  if (token == TokenKind.TRUE) return "'true'";
  if (token == TokenKind.UNSAFE) return "'unsafe'";
  if (token == TokenKind.VAR) return "'var'";
  if (token == TokenKind.WHILE) return "'while'";

  assert(false);
  return null;
}

function isAlpha(c: int): bool {
  return
    c >= 'a' && c <= 'z' ||
    c >= 'A' && c <= 'Z' ||
    c == '_';
}

function isNumber(c: int): bool {
  return c >= '0' && c <= '9';
}

function isDigit(c: int, base: int): bool {
  if (base == 16) {
    return isNumber(c) || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f';
  }
  return c >= '0' && c < '0' + base;
}

function tokenize(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = string_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = string_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(string_get(contents, i)) || isNumber(string_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var length = i - start;
      if (length >= 2 && length <= 10) {
        var text = string_slice(contents, start, i);

        if (length == 2) {
          if (string_equals(text, "as")) kind = TokenKind.AS; else
          if (string_equals(text, "if")) kind = TokenKind.IF;
        }

        else if (length == 3) {
          if (string_equals(text, "let")) kind = TokenKind.LET; else
          if (string_equals(text, "new")) kind = TokenKind.NEW; else
          if (string_equals(text, "var")) kind = TokenKind.VAR;
        }

        else if (length == 4) {
          if (string_equals(text, "else")) kind = TokenKind.ELSE; else
          if (string_equals(text, "enum")) kind = TokenKind.ENUM; else
          if (string_equals(text, "null")) kind = TokenKind.NULL; else
          if (string_equals(text, "this")) kind = TokenKind.THIS; else
          if (string_equals(text, "true")) kind = TokenKind.TRUE;
        }

        else if (length == 5) {
          if (string_equals(text, "break")) kind = TokenKind.BREAK; else
          if (string_equals(text, "class")) kind = TokenKind.CLASS; else
          if (string_equals(text, "const")) kind = TokenKind.CONST; else
          if (string_equals(text, "false")) kind = TokenKind.FALSE; else
          if (string_equals(text, "while")) kind = TokenKind.WHILE;
        }

        else if (length == 6) {
          if (string_equals(text, "export")) kind = TokenKind.EXPORT; else
          if (string_equals(text, "extern")) kind = TokenKind.EXTERN; else
          if (string_equals(text, "import")) kind = TokenKind.IMPORT; else
          if (string_equals(text, "public")) kind = TokenKind.PUBLIC; else
          if (string_equals(text, "return")) kind = TokenKind.RETURN; else
          if (string_equals(text, "sizeof")) kind = TokenKind.SIZEOF; else
          if (string_equals(text, "static")) kind = TokenKind.STATIC; else
          if (string_equals(text, "unsafe")) kind = TokenKind.UNSAFE;
        }

        else if (length == 7) {
          if (string_equals(text, "alignof")) kind = TokenKind.ALIGNOF; else
          if (string_equals(text, "declare")) kind = TokenKind.DECLARE; else
          if (string_equals(text, "extends")) kind = TokenKind.EXTENDS; else
          if (string_equals(text, "private")) kind = TokenKind.PRIVATE;
        }

        else {
          if (string_equals(text, "continue")) kind = TokenKind.CONTINUE; else
          if (string_equals(text, "function")) kind = TokenKind.FUNCTION; else
          if (string_equals(text, "implements")) kind = TokenKind.IMPLEMENTS; else
          if (string_equals(text, "interface")) kind = TokenKind.INTERFACE; else
          if (string_equals(text, "protected")) kind = TokenKind.PROTECTED;
        }
      }
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      if (i < limit) {
        var next = string_get(contents, i);
        var base = 10;

        // Handle binary, octal, and hexadecimal prefixes
        if (c == '0' && i + 1 < limit) {
          if (next == 'b' || next == 'B') base = 2;
          else if (next == 'o' || next == 'O') base = 8;
          else if (next == 'x' || next == 'X') base = 16;
          if (base != 10) {
            if (isDigit(string_get(contents, i + 1), base)) i = i + 2;
            else base = 10;
          }
        }

        // Scan the payload
        while (i < limit && isDigit(string_get(contents, i), base)) {
          i = i + 1;
        }

        // Extra letters after the end is an error
        if (i < limit && (isAlpha(string_get(contents, i)) || isNumber(string_get(contents, i)))) {
          i = i + 1;

          while (i < limit && (isAlpha(string_get(contents, i)) || isNumber(string_get(contents, i)))) {
            i = i + 1;
          }

          log.error(createRange(source, start, i), String_appendNew(String_appendNew(
            String_new("Invalid integer literal: '"),
            string_slice(contents, start, i)),
            "'"));
          return null;
        }
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = string_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && string_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && string_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && string_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = string_get(contents, i);

          if (next == '*' && i + 1 < limit && string_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && string_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && string_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && string_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && string_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && string_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && string_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && string_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && string_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = string_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = string_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range, String_appendNew(String_appendNew(
        String_new("Syntax error: '"),
        string_slice(contents, start, start + 1)),
        "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}
