// Casting to this enables writing to arbitrary locations in memory
unsafe class UBytePtr {
  value: ubyte;
}

class ByteArray {
  unsafe _data: uint;
  unsafe _length: uint;
  unsafe _capacity: uint;

  length(): int {
    unsafe {
      return this._length as int;
    }
  }

  get(index: int): ubyte {
    unsafe {
      assert((index as uint) < this._length);
      return ((this._data as int + index) as UBytePtr).value;
    }
  }

  set(index: int, value: ubyte): void {
    unsafe {
      assert((index as uint) < this._length);
      ((this._data as int + index) as UBytePtr).value = value;
    }
  }

  append(value: ubyte): void {
    unsafe {
      var offset = this._length;
      this._resize(offset + 1);
      ((this._data + offset) as UBytePtr).value = value;
    }
  }

  handle(): int {
    unsafe {
      return this as int;
    }
  }

  unsafe _resize(length: uint): void {
    if (length > this._capacity) {
      var capacity = length * 2;
      var data = malloc(capacity);
      var source = this._data;
      var limit = this._length;
      var i: uint = 0;

      // Copy the old bytes over
      while (i < limit) {
        ((data + i) as UBytePtr).value = ((source + i) as UBytePtr).value;
        i = i + 1;
      }

      // Swap in the new bytes
      this._capacity = capacity;
      this._data = data;
    }

    this._length = length;
  }
}
