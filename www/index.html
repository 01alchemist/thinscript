<meta charset="utf8">
<style>
  body {
    font-family: sans-serif;
    line-height: 150%;
    margin: 50px 0 50px 50px;
  }

  h1, p {
    padding-right: 50px;
  }

  button {
    float: right;
  }

  textarea {
    width: 100%;
    height: 400px;
    font-family: monospace;
  }

  section {
    width: 50%;
    float: left;
    padding-right: 50px;
    box-sizing: border-box;
  }
</style>
<body>
  <h1>ZeroScript Compiler Demo</h1>
  <p>
    Compile using:
    <label><input type="radio" name="backend" id="backend-js"> JavaScript</label>
    <label><input type="radio" name="backend" id="backend-wasm"> WebAssembly</label>
    <br>
    Compile to:
    <label><input type="radio" name="target" id="target-js"> JavaScript</label>
    <label><input type="radio" name="target" id="target-wasm" checked> WebAssembly</label>
  </p>

  <section>
    <h2>Input</h2>
    <textarea id="input" autofocus></textarea>
  </section>

  <section>
    <h2>Output <button id="download">Download</button></h2>
    <textarea id="output" readonly></textarea>
  </section>
</body>
<script>

(function() {
  var input = document.getElementById('input');
  var output = document.getElementById('output');
  var download = document.getElementById('download');

  var backendWebAssembly = document.getElementById('backend-wasm');
  var backendJavaScript = document.getElementById('backend-js');

  var targetWebAssembly = document.getElementById('target-wasm');
  var targetJavaScript = document.getElementById('target-js');

  var loadedWebAssembly = null;
  var loadedJavaScript = null;

  var downloadName = null;
  var blobToDownload = null;

  var example =
    'class Link {\n' +
    '  value: int;\n' +
    '  next: Link;\n' +
    '}\n' +
    '\n' +
    'class List {\n' +
    '  first: Link;\n' +
    '  last: Link;\n' +
    '}\n' +
    '\n' +
    'function append(list: List, value: int): void {\n' +
    '  var link = new Link();\n' +
    '  link.value = value;\n' +
    '\n' +
    '  if (list.first == null) {\n' +
    '    list.first = link;\n' +
    '  } else {\n' +
    '    list.last.next = link;\n' +
    '  }\n' +
    '  list.last = link;\n' +
    '}\n' +
    '\n' +
    'function main(): int {\n' +
    '  var list = new List();\n' +
    '  append(list, 1);\n' +
    '  append(list, 2);\n' +
    '  append(list, 3);\n' +
    '\n' +
    '  var total = 0;\n' +
    '  var link = list.first;\n' +
    '  while (link != null) {\n' +
    '    total = total + link.value;\n' +
    '    link = link.next;\n' +
    '  }\n' +
    '\n' +
    '  return total;\n' +
    '}\n';

  function avoidErrorSwallowing(promise) {
    promise.catch(function(error) {
      setTimeout(function() {
        throw error;
      });
    });
    return promise;
  }

  function loadJavaScript(callback) {
    var name = 'compiled.js';
    avoidErrorSwallowing(fetch(name).then(function(response) {
      return response.text();
    }).then(function(text) {
      callback(text);
    }));
  }

  function loadWebAssembly(callback) {
    var name = 'compiled.wasm';
    avoidErrorSwallowing(fetch(name).then(function(response) {
      return response.arrayBuffer();
    }).then(function(buffer) {
      callback(new Uint8Array(buffer));
    }));
  }

  function parseString(bytes, index) {
    var text = '';
    var c;

    while ((c = bytes[index]) !== 0) {
      text += String.fromCharCode(c);
      index++;
    }

    return text;
  }

  function loadStdlibForWebAssembly() {
    var arrays = [];
    var strings = [];
    var stdlib = {
      arrays: arrays,
      strings: strings,
      heapOffset: 0,
      bytes: null,

      'new': function(size) {
        var result = stdlib.heapOffset;
        size = (size + 7) & ~7;
        stdlib.heapOffset += size; // Use a simple bump allocator for now
        return result;
      },

      assert: function(truth) {
        if (!truth) {
          throw new Error('Assertion failed');
        }
      },

      String_new: function(ptr) {
        strings.push(parseString(stdlib.bytes, ptr));
        return strings.length;
      },

      String_length: function(self) {
        return strings[self - 1].length;
      },

      String_get: function(self, index) {
        return strings[self - 1].charCodeAt(index);
      },

      String_append: function(self, other) {
        strings.push(strings[self - 1] + strings[other - 1]);
        return strings.length;
      },

      String_appendNew: function(self, other) {
        strings.push(strings[self - 1] + parseString(stdlib.bytes, other));
        return strings.length;
      },

      String_slice: function(self, start, end) {
        strings.push(strings[self - 1].slice(start, end));
        return strings.length;
      },

      String_equal: function(self, other) {
        return strings[self - 1] === strings[other - 1];
      },

      String_equalNew: function(self, other) {
        return strings[self - 1] === parseString(stdlib.bytes, other);
      },

      String_toString: function(value) {
        strings.push(value.toString());
        return strings.length;
      },

      String_quote: function(self) {
        strings.push(JSON.stringify(strings[self - 1]));
        return strings.length;
      },

      ByteArray_new: function() {
        arrays.push([]);
        return arrays.length;
      },

      ByteArray_length: function(self) {
        return arrays[self - 1].length;
      },

      ByteArray_getByte: function(self, index) {
        return arrays[self - 1][index];
      },

      ByteArray_setByte: function(self, index, byte) {
        arrays[self - 1][index] = byte & 255;
      },

      ByteArray_appendByte: function(self, byte) {
        arrays[self - 1].push(byte & 255);
      },
    };
    return stdlib;
  }

  function loadStdlibForJavaScript() {
    return {
      assert: function(truth) {
        if (!truth) {
          throw new Error('Assertion failed');
        }
      },

      String_new: function(value) {
        return value;
      },

      String_length: function(self) {
        return self.length;
      },

      String_get: function(self, index) {
        return self.charCodeAt(index);
      },

      String_append: function(self, other) {
        return self + other;
      },

      String_appendNew: function(self, other) {
        return self + other;
      },

      String_slice: function(self, start, end) {
        return self.slice(start, end);
      },

      String_equal: function(self, other) {
        return self === other;
      },

      String_equalNew: function(self, other) {
        return self === other;
      },

      String_toString: function(value) {
        return value.toString();
      },

      String_quote: function(self) {
        return JSON.stringify(self);
      },

      ByteArray_new: function() {
        return [];
      },

      ByteArray_length: function(self) {
        return self.length;
      },

      ByteArray_getByte: function(self, index) {
        return self[index];
      },

      ByteArray_setByte: function(self, index, byte) {
        self[index] = byte & 255;
      },

      ByteArray_appendByte: function(self, byte) {
        self.push(byte & 255);
      },
    };
  }

  function compileAndRunWebAssembly(code, input) {
    var stdlib = loadStdlibForWebAssembly();
    var module = Wasm.instantiateModule(code, {imports: stdlib});
    var exports = module.exports;
    var memory = exports.memory;
    stdlib.bytes = new Uint8Array(memory);
    stdlib.heapOffset = new Int32Array(memory)[2];
    stdlib.strings.push(input);
    var result = exports.main(stdlib.strings.length);
    var wasm = stdlib.arrays[exports.CompileResult_wasm(result) - 1];
    return {
      wasm: wasm ? new Uint8Array(wasm) : null,
      log: stdlib.strings[exports.CompileResult_log(result) - 1] || '',
      js: stdlib.strings[exports.CompileResult_js(result) - 1] || '',
    };
  }

  function compileAndRunJavaScript(code, input) {
    var stdlib = loadStdlibForJavaScript();
    var exports = new Function('__imports',
      code + '\n' +
      'return {main: main, CompileResult_js: CompileResult_js, CompileResult_log: CompileResult_log, CompileResult_wasm: CompileResult_wasm};'
    )(stdlib);
    var result = exports.main(input);
    var wasm = exports.CompileResult_wasm(result);
    return {
      wasm: wasm ? new Uint8Array(wasm) : null,
      log: exports.CompileResult_log(result),
      js: exports.CompileResult_js(result),
    };
  }

  function hexdump(bytes) {
    var text = '';
    var rows = bytes.length + 15 >>> 4;

    for (var i = 0; i < rows; i++) {
      if (i > 0) {
        text += '\n';
      }

      var columns = Math.min(16, bytes.length - i * 16);

      for (var j = 0; j < columns; j++) {
        text += (0x100 | bytes[i * 16 + j]).toString(16).slice(-2) + ' ';
      }

      for (var j = columns; j < 16; j++) {
        text += '   ';
      }

      text += '| ';

      for (var j = 0; j < columns; j++) {
        var c = bytes[i * 16 + j];
        text += c >= 0x20 && c <= 0x7E ? String.fromCharCode(c) : '\xB7';
      }
    }

    return text;
  }

  function compile() {
    if (backendWebAssembly.checked) {
      var result = compileAndRunWebAssembly(loadedWebAssembly, input.value);
    } else {
      var result = compileAndRunJavaScript(loadedJavaScript, input.value);
    }

    if (result.log) {
      output.value = result.log;
      downloadName = 'log.txt';
      blobToDownload = new Blob([result.log], {type: 'text/plain'});
    }

    else if (targetJavaScript.checked) {
      output.value = result.js;
      downloadName = 'compiled.js';
      blobToDownload = new Blob([result.js], {type: 'text/plain'});
    }

    else {
      output.value = hexdump(result.wasm);
      downloadName = 'compiled.wasm';
      blobToDownload = new Blob([result.wasm], {type: 'application/octet-stream'});
    }
  }

  function downloadCompiledResult() {
    var link = document.createElement('a');
    link.href = URL.createObjectURL(blobToDownload);
    link.download = downloadName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  function main() {
    loadWebAssembly(function(wasm) {
      loadedWebAssembly = wasm;

      loadJavaScript(function(js) {
        loadedJavaScript = js;

        backendWebAssembly.onchange = compile;
        backendJavaScript.onchange = compile;
        targetWebAssembly.onchange = compile;
        targetJavaScript.onchange = compile;
        input.oninput = compile;
        download.onclick = downloadCompiledResult;

        if (typeof Wasm !== 'undefined') {
          backendWebAssembly.checked = true;
        } else {
          backendJavaScript.checked = true;
        }

        input.value = example;
        compile();
      });
    });
  }

  main();
})();

</script>
