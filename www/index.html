<meta charset="utf8">
<body></body>
<script>

(function() {
  function avoidErrorSwallowing(promise) {
    promise.catch(function(error) {
      setTimeout(function() {
        throw error;
      });
    });
    return promise;
  }

  function loadWasm(callback) {
    var name = 'compiled.wasm';
    avoidErrorSwallowing(fetch(name).then(function(response) {
      return response.arrayBuffer();
    }).then(function(buffer) {
      callback(new Uint8Array(buffer));
    }));
  }

  function fetchSourceCode(callback) {
    var sources = [
      '../src/checker.zs',
      '../src/entry.zs',
      '../src/js.zs',
      '../src/lexer.zs',
      '../src/node.zs',
      '../src/parser.zs',
      '../src/support.zs',
      '../src/wasm.zs',
    ];
    var promises = [];
    for (var i = 0; i < sources.length; i++) {
      promises.push(fetch(sources[i]));
    }
    avoidErrorSwallowing(Promise.all(promises).then(function(all) {
      return Promise.all(all.map(function(response) {
        return response.text();
      }));
    }).then(function(all) {
      callback(all.join('\n'));
    }));
  }

  function parseString(bytes, index) {
    var text = '';
    var c;

    while ((c = bytes[index]) !== 0) {
      text += String.fromCharCode(c);
      index++;
    }

    return text;
  }

  function loadStdlib() {
    var arrays = [];
    var strings = [];
    var stdlib = {
      arrays: arrays,
      strings: strings,
      heapOffset: 0,
      bytes: null,

      'new': function(size) {
        var result = stdlib.heapOffset;
        size = (size + 7) & ~7;
        stdlib.heapOffset += size; // Use a simple bump allocator for now
        return result;
      },

      assert: function(truth) {
        if (!truth) {
          throw new Error('Assertion failed');
        }
      },

      IO_print: function(value) {
        console.log(strings[value - 1]);
      },

      String_new: function(ptr) {
        strings.push(parseString(stdlib.bytes, ptr));
        return strings.length;
      },

      String_length: function(self) {
        return strings[self - 1].length;
      },

      String_get: function(self, index) {
        return strings[self - 1].charCodeAt(index);
      },

      String_append: function(self, other) {
        strings.push(strings[self - 1] + strings[other - 1]);
        return strings.length;
      },

      String_appendNew: function(self, other) {
        strings.push(strings[self - 1] + parseString(stdlib.bytes, other));
        return strings.length;
      },

      String_slice: function(self, start, end) {
        strings.push(strings[self - 1].slice(start, end));
        return strings.length;
      },

      String_equal: function(self, other) {
        return strings[self - 1] === strings[other - 1];
      },

      String_equalNew: function(self, other) {
        return strings[self - 1] === parseString(stdlib.bytes, other);
      },

      String_toString: function(value) {
        strings.push(value.toString());
        return strings.length;
      },

      String_quote: function(self) {
        strings.push(JSON.stringify(strings[self - 1]));
        return strings.length;
      },

      ByteArray_new: function() {
        arrays.push([]);
        return arrays.length;
      },

      ByteArray_length: function(self) {
        return arrays[self - 1].length;
      },

      ByteArray_getByte: function(self, index) {
        return arrays[self - 1][index];
      },

      ByteArray_setByte: function(self, index, byte) {
        arrays[self - 1][index] = byte & 255;
      },

      ByteArray_appendByte: function(self, byte) {
        arrays[self - 1].push(byte & 255);
      },
    };
    return stdlib;
  }

  function main() {
    loadWasm(function(bytes) {
      fetchSourceCode(function(sourceCode) {
        var stdlib = loadStdlib();
        var module = Wasm.instantiateModule(bytes, {imports: stdlib});
        var exports = module.exports;
        var memory = exports.memory;
        stdlib.bytes = new Uint8Array(memory);
        stdlib.heapOffset = new Int32Array(memory)[2];
        stdlib.strings.push(sourceCode);

        var result = exports.main(stdlib.strings.length);
        var wasm = new Uint8Array(stdlib.arrays[exports.CompileResult_wasm(result) - 1]);
        var log = stdlib.strings[exports.CompileResult_log(result) - 1] || '';
        var js = stdlib.strings[exports.CompileResult_js(result) - 1] || '';
        console.log('done #1, ' +
          'wasm length ' + (wasm && wasm.length) + ', ' +
          'log length ' + log.length + ', ' +
          'js length ' + js.length);
        if (log) {
          console.log(log);
          return;
        }

        var stdlib2 = loadStdlib();
        var module = Wasm.instantiateModule(wasm, {imports: stdlib2});
        var exports = module.exports;
        var memory = exports.memory;
        stdlib2.bytes = new Uint8Array(memory);
        stdlib2.heapOffset = new Int32Array(memory)[2];
        stdlib2.strings.push(sourceCode);

        var result = exports.main(stdlib2.strings.length);
        var wasm = new Uint8Array(stdlib2.arrays[exports.CompileResult_wasm(result) - 1]);
        var log = stdlib2.strings[exports.CompileResult_log(result) - 1] || '';
        var js = stdlib2.strings[exports.CompileResult_js(result) - 1] || '';
        console.log('done #2, ' +
          'wasm length ' + (wasm && wasm.length) + ', ' +
          'log length ' + log.length + ', ' +
          'js length ' + js.length);
        if (log) {
          console.log(log);
          return;
        }

        var link = document.createElement('a');
        link.href = URL.createObjectURL(new Blob([wasm], {type: 'application/octet-stream'}));
        link.download = 'compiled.wasm';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      });
    });
  }

  main();
})();

</script>
